// DO NOT EDIT.
// swift-format-ignore-file
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: sinch/cnt/v1alpha1/content_types.proto
//
// For information on using the generated types, please see the documentation:
//   https://github.com/apple/swift-protobuf/

import Foundation
import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that you are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

/// Corresponding numbers in enum (apart from UNSPECIFIED/INDEFINITE)
/// MUST match number of expiration days, since they are used for generating
/// lifecycle rules
enum Sinch_Cnt_V1alpha1_Expiration: SwiftProtobuf.Enum {
  typealias RawValue = Int
  case unspecified // = 0
  case oneDay // = 1
  case twoDays // = 2
  case threeDays // = 3
  case fourDays // = 4
  case fiveDays // = 5
  case sixDays // = 6
  case sevenDays // = 7
  case twoWeeks // = 14
  case threeWeeks // = 21
  case fourWeeks // = 28
  case indefinite // = 1000
  case UNRECOGNIZED(Int)

  init() {
    self = .unspecified
  }

  init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .unspecified
    case 1: self = .oneDay
    case 2: self = .twoDays
    case 3: self = .threeDays
    case 4: self = .fourDays
    case 5: self = .fiveDays
    case 6: self = .sixDays
    case 7: self = .sevenDays
    case 14: self = .twoWeeks
    case 21: self = .threeWeeks
    case 28: self = .fourWeeks
    case 1000: self = .indefinite
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  var rawValue: Int {
    switch self {
    case .unspecified: return 0
    case .oneDay: return 1
    case .twoDays: return 2
    case .threeDays: return 3
    case .fourDays: return 4
    case .fiveDays: return 5
    case .sixDays: return 6
    case .sevenDays: return 7
    case .twoWeeks: return 14
    case .threeWeeks: return 21
    case .fourWeeks: return 28
    case .indefinite: return 1000
    case .UNRECOGNIZED(let i): return i
    }
  }

}

#if swift(>=4.2)

extension Sinch_Cnt_V1alpha1_Expiration: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  static var allCases: [Sinch_Cnt_V1alpha1_Expiration] = [
    .unspecified,
    .oneDay,
    .twoDays,
    .threeDays,
    .fourDays,
    .fiveDays,
    .sixDays,
    .sevenDays,
    .twoWeeks,
    .threeWeeks,
    .fourWeeks,
    .indefinite,
  ]
}

#endif  // swift(>=4.2)

enum Sinch_Cnt_V1alpha1_TargetBucket: SwiftProtobuf.Enum {
  typealias RawValue = Int
  case bucketUnspecified // = 0
  case `public` // = 1
  case `private` // = 2
  case UNRECOGNIZED(Int)

  init() {
    self = .bucketUnspecified
  }

  init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .bucketUnspecified
    case 1: self = .public
    case 2: self = .private
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  var rawValue: Int {
    switch self {
    case .bucketUnspecified: return 0
    case .public: return 1
    case .private: return 2
    case .UNRECOGNIZED(let i): return i
    }
  }

}

#if swift(>=4.2)

extension Sinch_Cnt_V1alpha1_TargetBucket: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  static var allCases: [Sinch_Cnt_V1alpha1_TargetBucket] = [
    .bucketUnspecified,
    .public,
    .private,
  ]
}

#endif  // swift(>=4.2)

struct Sinch_Cnt_V1alpha1_GetFileRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var projectID: String = String()

  var objectKey: String = String()

  var bucketType: Sinch_Cnt_V1alpha1_TargetBucket = .bucketUnspecified

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Sinch_Cnt_V1alpha1_GetFileResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var data: Data = Data()

  var totalFileSize: Int64 = 0

  var chunkSize: Int32 = 0

  var mimeType: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Sinch_Cnt_V1alpha1_StoreFileFromUrlRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var projectID: String = String()

  var fileURL: String = String()

  var expires: Sinch_Cnt_V1alpha1_Expiration = .unspecified

  var mimeType: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Sinch_Cnt_V1alpha1_StoreFileRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var fileURL: String = String()

  var expires: Sinch_Cnt_V1alpha1_Expiration = .unspecified

  var mimeType: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Sinch_Cnt_V1alpha1_StoreFileFromUrlResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var fileURL: String = String()

  var mimeType: String = String()

  var contentLength: Int64 = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Sinch_Cnt_V1alpha1_StoreMultipleFilesFromUrlRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var projectID: String = String()

  var request: [Sinch_Cnt_V1alpha1_StoreFileRequest] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Sinch_Cnt_V1alpha1_StoreMultipleFilesFromUrlResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var response: [Sinch_Cnt_V1alpha1_StoreFileFromUrlResponse] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Sinch_Cnt_V1alpha1_GetOccupancyReportRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var projectID: String = String()

  var targetBucket: Sinch_Cnt_V1alpha1_TargetBucket = .bucketUnspecified

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Sinch_Cnt_V1alpha1_GetOccupancyReportResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var numOfObjects: Int64 = 0

  var sizeInBytes: Int64 = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Sinch_Cnt_V1alpha1_StoreBinaryDataRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var projectID: String = String()

  var fileMetadata: Sinch_Cnt_V1alpha1_FileMetadata {
    get {return _fileMetadata ?? Sinch_Cnt_V1alpha1_FileMetadata()}
    set {_fileMetadata = newValue}
  }
  /// Returns true if `fileMetadata` has been explicitly set.
  var hasFileMetadata: Bool {return self._fileMetadata != nil}
  /// Clears the value of `fileMetadata`. Subsequent reads from it will return its default value.
  mutating func clearFileMetadata() {self._fileMetadata = nil}

  var data: Data = Data()

  var targetBucket: Sinch_Cnt_V1alpha1_TargetBucket = .bucketUnspecified

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _fileMetadata: Sinch_Cnt_V1alpha1_FileMetadata? = nil
}

struct Sinch_Cnt_V1alpha1_StoreBinaryDataResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  ///empty for private buckets
  var fileURL: String = String()

  var mimeType: String = String()

  var contentLength: Int64 = 0

  ///key that data is stored at
  var objectKey: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Sinch_Cnt_V1alpha1_DeleteFileRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var projectID: String = String()

  var fileName: String = String()

  var targetBucket: Sinch_Cnt_V1alpha1_TargetBucket = .bucketUnspecified

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Sinch_Cnt_V1alpha1_DeleteFileResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var response: SwiftProtobuf.Google_Protobuf_Empty {
    get {return _response ?? SwiftProtobuf.Google_Protobuf_Empty()}
    set {_response = newValue}
  }
  /// Returns true if `response` has been explicitly set.
  var hasResponse: Bool {return self._response != nil}
  /// Clears the value of `response`. Subsequent reads from it will return its default value.
  mutating func clearResponse() {self._response = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _response: SwiftProtobuf.Google_Protobuf_Empty? = nil
}

struct Sinch_Cnt_V1alpha1_GetPreSignedUrlRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var projectID: String = String()

  var fileName: String = String()

  ///how long preSignedUrl will be valid, in seconds
  var urlExpiration: Int32 = 0

  ///when uploaded content will expire
  var fileExpiration: Sinch_Cnt_V1alpha1_Expiration = .unspecified

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Sinch_Cnt_V1alpha1_GetPreSignedUrlResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  ///Url where file should be uploaded to (with PUT method)
  var preSignedURL: String = String()

  ///Url where file is available after the upload
  var getURL: String = String()

  ///headers you have to attach to request
  var headers: Dictionary<String,String> = [:]

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Sinch_Cnt_V1alpha1_FileMetadata {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var mimeType: String = String()

  var expires: Sinch_Cnt_V1alpha1_Expiration = .unspecified

  var fileName: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

// MARK: - Code below here is support for the SwiftProtobuf runtime.

fileprivate let _protobuf_package = "sinch.cnt.v1alpha1"

extension Sinch_Cnt_V1alpha1_Expiration: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "EXPIRATION_UNSPECIFIED"),
    1: .same(proto: "EXPIRATION_ONE_DAY"),
    2: .same(proto: "EXPIRATION_TWO_DAYS"),
    3: .same(proto: "EXPIRATION_THREE_DAYS"),
    4: .same(proto: "EXPIRATION_FOUR_DAYS"),
    5: .same(proto: "EXPIRATION_FIVE_DAYS"),
    6: .same(proto: "EXPIRATION_SIX_DAYS"),
    7: .same(proto: "EXPIRATION_SEVEN_DAYS"),
    14: .same(proto: "EXPIRATION_TWO_WEEKS"),
    21: .same(proto: "EXPIRATION_THREE_WEEKS"),
    28: .same(proto: "EXPIRATION_FOUR_WEEKS"),
    1000: .same(proto: "EXPIRATION_INDEFINITE"),
  ]
}

extension Sinch_Cnt_V1alpha1_TargetBucket: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "BUCKET_UNSPECIFIED"),
    1: .same(proto: "PUBLIC"),
    2: .same(proto: "PRIVATE"),
  ]
}

extension Sinch_Cnt_V1alpha1_GetFileRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".GetFileRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "project_id"),
    2: .standard(proto: "object_key"),
    3: .standard(proto: "bucket_type"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.projectID) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.objectKey) }()
      case 3: try { try decoder.decodeSingularEnumField(value: &self.bucketType) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.projectID.isEmpty {
      try visitor.visitSingularStringField(value: self.projectID, fieldNumber: 1)
    }
    if !self.objectKey.isEmpty {
      try visitor.visitSingularStringField(value: self.objectKey, fieldNumber: 2)
    }
    if self.bucketType != .bucketUnspecified {
      try visitor.visitSingularEnumField(value: self.bucketType, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Sinch_Cnt_V1alpha1_GetFileRequest, rhs: Sinch_Cnt_V1alpha1_GetFileRequest) -> Bool {
    if lhs.projectID != rhs.projectID {return false}
    if lhs.objectKey != rhs.objectKey {return false}
    if lhs.bucketType != rhs.bucketType {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Sinch_Cnt_V1alpha1_GetFileResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".GetFileResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "data"),
    2: .standard(proto: "total_file_size"),
    3: .standard(proto: "chunk_size"),
    4: .standard(proto: "mime_type"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBytesField(value: &self.data) }()
      case 2: try { try decoder.decodeSingularInt64Field(value: &self.totalFileSize) }()
      case 3: try { try decoder.decodeSingularInt32Field(value: &self.chunkSize) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.mimeType) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.data.isEmpty {
      try visitor.visitSingularBytesField(value: self.data, fieldNumber: 1)
    }
    if self.totalFileSize != 0 {
      try visitor.visitSingularInt64Field(value: self.totalFileSize, fieldNumber: 2)
    }
    if self.chunkSize != 0 {
      try visitor.visitSingularInt32Field(value: self.chunkSize, fieldNumber: 3)
    }
    if !self.mimeType.isEmpty {
      try visitor.visitSingularStringField(value: self.mimeType, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Sinch_Cnt_V1alpha1_GetFileResponse, rhs: Sinch_Cnt_V1alpha1_GetFileResponse) -> Bool {
    if lhs.data != rhs.data {return false}
    if lhs.totalFileSize != rhs.totalFileSize {return false}
    if lhs.chunkSize != rhs.chunkSize {return false}
    if lhs.mimeType != rhs.mimeType {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Sinch_Cnt_V1alpha1_StoreFileFromUrlRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".StoreFileFromUrlRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "project_id"),
    2: .standard(proto: "file_url"),
    3: .same(proto: "expires"),
    4: .standard(proto: "mime_type"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.projectID) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.fileURL) }()
      case 3: try { try decoder.decodeSingularEnumField(value: &self.expires) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.mimeType) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.projectID.isEmpty {
      try visitor.visitSingularStringField(value: self.projectID, fieldNumber: 1)
    }
    if !self.fileURL.isEmpty {
      try visitor.visitSingularStringField(value: self.fileURL, fieldNumber: 2)
    }
    if self.expires != .unspecified {
      try visitor.visitSingularEnumField(value: self.expires, fieldNumber: 3)
    }
    if !self.mimeType.isEmpty {
      try visitor.visitSingularStringField(value: self.mimeType, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Sinch_Cnt_V1alpha1_StoreFileFromUrlRequest, rhs: Sinch_Cnt_V1alpha1_StoreFileFromUrlRequest) -> Bool {
    if lhs.projectID != rhs.projectID {return false}
    if lhs.fileURL != rhs.fileURL {return false}
    if lhs.expires != rhs.expires {return false}
    if lhs.mimeType != rhs.mimeType {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Sinch_Cnt_V1alpha1_StoreFileRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".StoreFileRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "file_url"),
    2: .same(proto: "expires"),
    3: .standard(proto: "mime_type"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.fileURL) }()
      case 2: try { try decoder.decodeSingularEnumField(value: &self.expires) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.mimeType) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.fileURL.isEmpty {
      try visitor.visitSingularStringField(value: self.fileURL, fieldNumber: 1)
    }
    if self.expires != .unspecified {
      try visitor.visitSingularEnumField(value: self.expires, fieldNumber: 2)
    }
    if !self.mimeType.isEmpty {
      try visitor.visitSingularStringField(value: self.mimeType, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Sinch_Cnt_V1alpha1_StoreFileRequest, rhs: Sinch_Cnt_V1alpha1_StoreFileRequest) -> Bool {
    if lhs.fileURL != rhs.fileURL {return false}
    if lhs.expires != rhs.expires {return false}
    if lhs.mimeType != rhs.mimeType {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Sinch_Cnt_V1alpha1_StoreFileFromUrlResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".StoreFileFromUrlResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "file_url"),
    2: .standard(proto: "mime_type"),
    3: .standard(proto: "content_length"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.fileURL) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.mimeType) }()
      case 3: try { try decoder.decodeSingularInt64Field(value: &self.contentLength) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.fileURL.isEmpty {
      try visitor.visitSingularStringField(value: self.fileURL, fieldNumber: 1)
    }
    if !self.mimeType.isEmpty {
      try visitor.visitSingularStringField(value: self.mimeType, fieldNumber: 2)
    }
    if self.contentLength != 0 {
      try visitor.visitSingularInt64Field(value: self.contentLength, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Sinch_Cnt_V1alpha1_StoreFileFromUrlResponse, rhs: Sinch_Cnt_V1alpha1_StoreFileFromUrlResponse) -> Bool {
    if lhs.fileURL != rhs.fileURL {return false}
    if lhs.mimeType != rhs.mimeType {return false}
    if lhs.contentLength != rhs.contentLength {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Sinch_Cnt_V1alpha1_StoreMultipleFilesFromUrlRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".StoreMultipleFilesFromUrlRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "project_id"),
    2: .same(proto: "request"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.projectID) }()
      case 2: try { try decoder.decodeRepeatedMessageField(value: &self.request) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.projectID.isEmpty {
      try visitor.visitSingularStringField(value: self.projectID, fieldNumber: 1)
    }
    if !self.request.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.request, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Sinch_Cnt_V1alpha1_StoreMultipleFilesFromUrlRequest, rhs: Sinch_Cnt_V1alpha1_StoreMultipleFilesFromUrlRequest) -> Bool {
    if lhs.projectID != rhs.projectID {return false}
    if lhs.request != rhs.request {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Sinch_Cnt_V1alpha1_StoreMultipleFilesFromUrlResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".StoreMultipleFilesFromUrlResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "response"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.response) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.response.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.response, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Sinch_Cnt_V1alpha1_StoreMultipleFilesFromUrlResponse, rhs: Sinch_Cnt_V1alpha1_StoreMultipleFilesFromUrlResponse) -> Bool {
    if lhs.response != rhs.response {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Sinch_Cnt_V1alpha1_GetOccupancyReportRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".GetOccupancyReportRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "project_id"),
    2: .standard(proto: "target_bucket"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.projectID) }()
      case 2: try { try decoder.decodeSingularEnumField(value: &self.targetBucket) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.projectID.isEmpty {
      try visitor.visitSingularStringField(value: self.projectID, fieldNumber: 1)
    }
    if self.targetBucket != .bucketUnspecified {
      try visitor.visitSingularEnumField(value: self.targetBucket, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Sinch_Cnt_V1alpha1_GetOccupancyReportRequest, rhs: Sinch_Cnt_V1alpha1_GetOccupancyReportRequest) -> Bool {
    if lhs.projectID != rhs.projectID {return false}
    if lhs.targetBucket != rhs.targetBucket {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Sinch_Cnt_V1alpha1_GetOccupancyReportResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".GetOccupancyReportResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "num_of_objects"),
    2: .standard(proto: "size_in_bytes"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt64Field(value: &self.numOfObjects) }()
      case 2: try { try decoder.decodeSingularInt64Field(value: &self.sizeInBytes) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.numOfObjects != 0 {
      try visitor.visitSingularInt64Field(value: self.numOfObjects, fieldNumber: 1)
    }
    if self.sizeInBytes != 0 {
      try visitor.visitSingularInt64Field(value: self.sizeInBytes, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Sinch_Cnt_V1alpha1_GetOccupancyReportResponse, rhs: Sinch_Cnt_V1alpha1_GetOccupancyReportResponse) -> Bool {
    if lhs.numOfObjects != rhs.numOfObjects {return false}
    if lhs.sizeInBytes != rhs.sizeInBytes {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Sinch_Cnt_V1alpha1_StoreBinaryDataRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".StoreBinaryDataRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "project_id"),
    2: .standard(proto: "file_metadata"),
    3: .same(proto: "data"),
    4: .standard(proto: "target_bucket"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.projectID) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._fileMetadata) }()
      case 3: try { try decoder.decodeSingularBytesField(value: &self.data) }()
      case 4: try { try decoder.decodeSingularEnumField(value: &self.targetBucket) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.projectID.isEmpty {
      try visitor.visitSingularStringField(value: self.projectID, fieldNumber: 1)
    }
    try { if let v = self._fileMetadata {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    if !self.data.isEmpty {
      try visitor.visitSingularBytesField(value: self.data, fieldNumber: 3)
    }
    if self.targetBucket != .bucketUnspecified {
      try visitor.visitSingularEnumField(value: self.targetBucket, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Sinch_Cnt_V1alpha1_StoreBinaryDataRequest, rhs: Sinch_Cnt_V1alpha1_StoreBinaryDataRequest) -> Bool {
    if lhs.projectID != rhs.projectID {return false}
    if lhs._fileMetadata != rhs._fileMetadata {return false}
    if lhs.data != rhs.data {return false}
    if lhs.targetBucket != rhs.targetBucket {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Sinch_Cnt_V1alpha1_StoreBinaryDataResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".StoreBinaryDataResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "file_url"),
    2: .standard(proto: "mime_type"),
    3: .standard(proto: "content_length"),
    4: .standard(proto: "object_key"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.fileURL) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.mimeType) }()
      case 3: try { try decoder.decodeSingularInt64Field(value: &self.contentLength) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.objectKey) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.fileURL.isEmpty {
      try visitor.visitSingularStringField(value: self.fileURL, fieldNumber: 1)
    }
    if !self.mimeType.isEmpty {
      try visitor.visitSingularStringField(value: self.mimeType, fieldNumber: 2)
    }
    if self.contentLength != 0 {
      try visitor.visitSingularInt64Field(value: self.contentLength, fieldNumber: 3)
    }
    if !self.objectKey.isEmpty {
      try visitor.visitSingularStringField(value: self.objectKey, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Sinch_Cnt_V1alpha1_StoreBinaryDataResponse, rhs: Sinch_Cnt_V1alpha1_StoreBinaryDataResponse) -> Bool {
    if lhs.fileURL != rhs.fileURL {return false}
    if lhs.mimeType != rhs.mimeType {return false}
    if lhs.contentLength != rhs.contentLength {return false}
    if lhs.objectKey != rhs.objectKey {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Sinch_Cnt_V1alpha1_DeleteFileRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".DeleteFileRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "project_id"),
    2: .standard(proto: "file_name"),
    3: .standard(proto: "target_bucket"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.projectID) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.fileName) }()
      case 3: try { try decoder.decodeSingularEnumField(value: &self.targetBucket) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.projectID.isEmpty {
      try visitor.visitSingularStringField(value: self.projectID, fieldNumber: 1)
    }
    if !self.fileName.isEmpty {
      try visitor.visitSingularStringField(value: self.fileName, fieldNumber: 2)
    }
    if self.targetBucket != .bucketUnspecified {
      try visitor.visitSingularEnumField(value: self.targetBucket, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Sinch_Cnt_V1alpha1_DeleteFileRequest, rhs: Sinch_Cnt_V1alpha1_DeleteFileRequest) -> Bool {
    if lhs.projectID != rhs.projectID {return false}
    if lhs.fileName != rhs.fileName {return false}
    if lhs.targetBucket != rhs.targetBucket {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Sinch_Cnt_V1alpha1_DeleteFileResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".DeleteFileResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "response"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._response) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._response {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Sinch_Cnt_V1alpha1_DeleteFileResponse, rhs: Sinch_Cnt_V1alpha1_DeleteFileResponse) -> Bool {
    if lhs._response != rhs._response {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Sinch_Cnt_V1alpha1_GetPreSignedUrlRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".GetPreSignedUrlRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "project_id"),
    2: .standard(proto: "file_name"),
    3: .standard(proto: "url_expiration"),
    4: .standard(proto: "file_expiration"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.projectID) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.fileName) }()
      case 3: try { try decoder.decodeSingularInt32Field(value: &self.urlExpiration) }()
      case 4: try { try decoder.decodeSingularEnumField(value: &self.fileExpiration) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.projectID.isEmpty {
      try visitor.visitSingularStringField(value: self.projectID, fieldNumber: 1)
    }
    if !self.fileName.isEmpty {
      try visitor.visitSingularStringField(value: self.fileName, fieldNumber: 2)
    }
    if self.urlExpiration != 0 {
      try visitor.visitSingularInt32Field(value: self.urlExpiration, fieldNumber: 3)
    }
    if self.fileExpiration != .unspecified {
      try visitor.visitSingularEnumField(value: self.fileExpiration, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Sinch_Cnt_V1alpha1_GetPreSignedUrlRequest, rhs: Sinch_Cnt_V1alpha1_GetPreSignedUrlRequest) -> Bool {
    if lhs.projectID != rhs.projectID {return false}
    if lhs.fileName != rhs.fileName {return false}
    if lhs.urlExpiration != rhs.urlExpiration {return false}
    if lhs.fileExpiration != rhs.fileExpiration {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Sinch_Cnt_V1alpha1_GetPreSignedUrlResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".GetPreSignedUrlResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "pre_signed_url"),
    2: .standard(proto: "get_url"),
    3: .same(proto: "headers"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.preSignedURL) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.getURL) }()
      case 3: try { try decoder.decodeMapField(fieldType: SwiftProtobuf._ProtobufMap<SwiftProtobuf.ProtobufString,SwiftProtobuf.ProtobufString>.self, value: &self.headers) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.preSignedURL.isEmpty {
      try visitor.visitSingularStringField(value: self.preSignedURL, fieldNumber: 1)
    }
    if !self.getURL.isEmpty {
      try visitor.visitSingularStringField(value: self.getURL, fieldNumber: 2)
    }
    if !self.headers.isEmpty {
      try visitor.visitMapField(fieldType: SwiftProtobuf._ProtobufMap<SwiftProtobuf.ProtobufString,SwiftProtobuf.ProtobufString>.self, value: self.headers, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Sinch_Cnt_V1alpha1_GetPreSignedUrlResponse, rhs: Sinch_Cnt_V1alpha1_GetPreSignedUrlResponse) -> Bool {
    if lhs.preSignedURL != rhs.preSignedURL {return false}
    if lhs.getURL != rhs.getURL {return false}
    if lhs.headers != rhs.headers {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Sinch_Cnt_V1alpha1_FileMetadata: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".FileMetadata"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    2: .standard(proto: "mime_type"),
    3: .same(proto: "expires"),
    4: .standard(proto: "file_name"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 2: try { try decoder.decodeSingularStringField(value: &self.mimeType) }()
      case 3: try { try decoder.decodeSingularEnumField(value: &self.expires) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.fileName) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.mimeType.isEmpty {
      try visitor.visitSingularStringField(value: self.mimeType, fieldNumber: 2)
    }
    if self.expires != .unspecified {
      try visitor.visitSingularEnumField(value: self.expires, fieldNumber: 3)
    }
    if !self.fileName.isEmpty {
      try visitor.visitSingularStringField(value: self.fileName, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Sinch_Cnt_V1alpha1_FileMetadata, rhs: Sinch_Cnt_V1alpha1_FileMetadata) -> Bool {
    if lhs.mimeType != rhs.mimeType {return false}
    if lhs.expires != rhs.expires {return false}
    if lhs.fileName != rhs.fileName {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}
