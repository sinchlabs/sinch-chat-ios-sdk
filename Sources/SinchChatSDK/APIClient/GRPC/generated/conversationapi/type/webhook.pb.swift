// DO NOT EDIT.
// swift-format-ignore-file
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: sinch/conversationapi/type/webhook.proto
//
// For information on using the generated types, please see the documentation:
//   https://github.com/apple/swift-protobuf/

import Foundation
import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that you are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

enum Sinch_Conversationapi_Type_WebhookTargetType: SwiftProtobuf.Enum {
  typealias RawValue = Int
  case dismiss // = 0
  case grpc // = 1
  case http // = 2
  case UNRECOGNIZED(Int)

  init() {
    self = .dismiss
  }

  init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .dismiss
    case 1: self = .grpc
    case 2: self = .http
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  var rawValue: Int {
    switch self {
    case .dismiss: return 0
    case .grpc: return 1
    case .http: return 2
    case .UNRECOGNIZED(let i): return i
    }
  }

}

#if swift(>=4.2)

extension Sinch_Conversationapi_Type_WebhookTargetType: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  static var allCases: [Sinch_Conversationapi_Type_WebhookTargetType] = [
    .dismiss,
    .grpc,
    .http,
  ]
}

#endif  // swift(>=4.2)

/// En event triggering Conversation API callback
enum Sinch_Conversationapi_Type_WebhookTrigger: SwiftProtobuf.Enum {
  typealias RawValue = Int

  /// Using this value will cause errors.
  case unspecifiedTrigger // = 0

  /// Subscribe to delivery receipts for a message sent.
  case messageDelivery // = 1

  /// Subscribe to delivery receipts for a event sent.
  case eventDelivery // = 2

  /// Subscribe to inbound messages from end users on the underlying channels.
  case messageInbound // = 3

  /// Subscribe to inbound events from end users on the underlying channels.
  case eventInbound // = 4

  /// Subscribe to an event that is triggered when a new conversation has been started.
  case conversationStart // = 5

  /// Subscribe to an event that is triggered when a active conversation has been stopped.
  case conversationStop // = 6

  /// Subscribe to an event that is triggered when a new contact has been created.
  case contactCreate // = 7

  /// Subscribe to an event that is triggered when a contact has been deleted.
  case contactDelete // = 8

  /// Subscribe to an event that is triggered when a two contacts are merged.
  case contactMerge // = 9

  /// Subscribe to callbacks that are not natively supported by the Conversation API.
  case unsupported // = 10

  /// Subscribe to opt_ins.
  case optIn // = 11

  /// Subscribe to opt_outs.
  case optOut // = 12

  /// Subscribe to see get capability results.
  case capability // = 13

  /// Subscribe to get an event when a conversation is deleted
  case conversationDelete // = 14
  case UNRECOGNIZED(Int)

  init() {
    self = .unspecifiedTrigger
  }

  init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .unspecifiedTrigger
    case 1: self = .messageDelivery
    case 2: self = .eventDelivery
    case 3: self = .messageInbound
    case 4: self = .eventInbound
    case 5: self = .conversationStart
    case 6: self = .conversationStop
    case 7: self = .contactCreate
    case 8: self = .contactDelete
    case 9: self = .contactMerge
    case 10: self = .unsupported
    case 11: self = .optIn
    case 12: self = .optOut
    case 13: self = .capability
    case 14: self = .conversationDelete
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  var rawValue: Int {
    switch self {
    case .unspecifiedTrigger: return 0
    case .messageDelivery: return 1
    case .eventDelivery: return 2
    case .messageInbound: return 3
    case .eventInbound: return 4
    case .conversationStart: return 5
    case .conversationStop: return 6
    case .contactCreate: return 7
    case .contactDelete: return 8
    case .contactMerge: return 9
    case .unsupported: return 10
    case .optIn: return 11
    case .optOut: return 12
    case .capability: return 13
    case .conversationDelete: return 14
    case .UNRECOGNIZED(let i): return i
    }
  }

}

#if swift(>=4.2)

extension Sinch_Conversationapi_Type_WebhookTrigger: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  static var allCases: [Sinch_Conversationapi_Type_WebhookTrigger] = [
    .unspecifiedTrigger,
    .messageDelivery,
    .eventDelivery,
    .messageInbound,
    .eventInbound,
    .conversationStart,
    .conversationStop,
    .contactCreate,
    .contactDelete,
    .contactMerge,
    .unsupported,
    .optIn,
    .optOut,
    .capability,
    .conversationDelete,
  ]
}

#endif  // swift(>=4.2)

/// Webhook
///
/// Represents a destination for receiving callbacks from the Conversation API. 
struct Sinch_Conversationapi_Type_Webhook {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Output only. The ID of the webhook.
  var id: String = String()

  /// The app that this webhook belongs to.
  var appID: String = String()

  /// The target url where events should be sent to.
  /// Maximum URL length is 742. 
  var target: String = String()

  /// Type of the target url.
  var targetType: Sinch_Conversationapi_Type_WebhookTargetType = .dismiss

  /// Optional secret be used to sign contents of webhooks sent by the Conversation API.
  /// You can then use the secret to verify the signature. 
  var secret: String = String()

  /// An array of triggers that should trigger the webhook and result in a
  /// event being sent to the target url. 
  var triggers: [Sinch_Conversationapi_Type_WebhookTrigger] = []

  /// Optional. Client Credentials that will be used to obtain and attach an Access Token
  /// to the callbacks originating from the Conversation API. 
  var clientCredentials: Sinch_Conversationapi_Type_ClientCredentials {
    get {return _clientCredentials ?? Sinch_Conversationapi_Type_ClientCredentials()}
    set {_clientCredentials = newValue}
  }
  /// Returns true if `clientCredentials` has been explicitly set.
  var hasClientCredentials: Bool {return self._clientCredentials != nil}
  /// Clears the value of `clientCredentials`. Subsequent reads from it will return its default value.
  mutating func clearClientCredentials() {self._clientCredentials = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _clientCredentials: Sinch_Conversationapi_Type_ClientCredentials? = nil
}

struct Sinch_Conversationapi_Type_ClientCredentials {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Required. The endpoint that will be used in the Client Credentials flow.
  var endpoint: String = String()

  /// Required. The Client ID that will be used in the Client Credentials flow.
  var clientID: String = String()

  /// Required. The Client Secret that will be used in the Client Credentials flow.
  var clientSecret: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

#if swift(>=5.5) && canImport(_Concurrency)
extension Sinch_Conversationapi_Type_WebhookTargetType: @unchecked Sendable {}
extension Sinch_Conversationapi_Type_WebhookTrigger: @unchecked Sendable {}
extension Sinch_Conversationapi_Type_Webhook: @unchecked Sendable {}
extension Sinch_Conversationapi_Type_ClientCredentials: @unchecked Sendable {}
#endif  // swift(>=5.5) && canImport(_Concurrency)

// MARK: - Code below here is support for the SwiftProtobuf runtime.

fileprivate let _protobuf_package = "sinch.conversationapi.type"

extension Sinch_Conversationapi_Type_WebhookTargetType: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "DISMISS"),
    1: .same(proto: "GRPC"),
    2: .same(proto: "HTTP"),
  ]
}

extension Sinch_Conversationapi_Type_WebhookTrigger: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "UNSPECIFIED_TRIGGER"),
    1: .same(proto: "MESSAGE_DELIVERY"),
    2: .same(proto: "EVENT_DELIVERY"),
    3: .same(proto: "MESSAGE_INBOUND"),
    4: .same(proto: "EVENT_INBOUND"),
    5: .same(proto: "CONVERSATION_START"),
    6: .same(proto: "CONVERSATION_STOP"),
    7: .same(proto: "CONTACT_CREATE"),
    8: .same(proto: "CONTACT_DELETE"),
    9: .same(proto: "CONTACT_MERGE"),
    10: .same(proto: "UNSUPPORTED"),
    11: .same(proto: "OPT_IN"),
    12: .same(proto: "OPT_OUT"),
    13: .same(proto: "CAPABILITY"),
    14: .same(proto: "CONVERSATION_DELETE"),
  ]
}

extension Sinch_Conversationapi_Type_Webhook: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".Webhook"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "id"),
    2: .standard(proto: "app_id"),
    3: .same(proto: "target"),
    4: .standard(proto: "target_type"),
    5: .same(proto: "secret"),
    6: .same(proto: "triggers"),
    7: .standard(proto: "client_credentials"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.id) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.appID) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.target) }()
      case 4: try { try decoder.decodeSingularEnumField(value: &self.targetType) }()
      case 5: try { try decoder.decodeSingularStringField(value: &self.secret) }()
      case 6: try { try decoder.decodeRepeatedEnumField(value: &self.triggers) }()
      case 7: try { try decoder.decodeSingularMessageField(value: &self._clientCredentials) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.id.isEmpty {
      try visitor.visitSingularStringField(value: self.id, fieldNumber: 1)
    }
    if !self.appID.isEmpty {
      try visitor.visitSingularStringField(value: self.appID, fieldNumber: 2)
    }
    if !self.target.isEmpty {
      try visitor.visitSingularStringField(value: self.target, fieldNumber: 3)
    }
    if self.targetType != .dismiss {
      try visitor.visitSingularEnumField(value: self.targetType, fieldNumber: 4)
    }
    if !self.secret.isEmpty {
      try visitor.visitSingularStringField(value: self.secret, fieldNumber: 5)
    }
    if !self.triggers.isEmpty {
      try visitor.visitPackedEnumField(value: self.triggers, fieldNumber: 6)
    }
    try { if let v = self._clientCredentials {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 7)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Sinch_Conversationapi_Type_Webhook, rhs: Sinch_Conversationapi_Type_Webhook) -> Bool {
    if lhs.id != rhs.id {return false}
    if lhs.appID != rhs.appID {return false}
    if lhs.target != rhs.target {return false}
    if lhs.targetType != rhs.targetType {return false}
    if lhs.secret != rhs.secret {return false}
    if lhs.triggers != rhs.triggers {return false}
    if lhs._clientCredentials != rhs._clientCredentials {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Sinch_Conversationapi_Type_ClientCredentials: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ClientCredentials"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "endpoint"),
    2: .standard(proto: "client_id"),
    3: .standard(proto: "client_secret"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.endpoint) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.clientID) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.clientSecret) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.endpoint.isEmpty {
      try visitor.visitSingularStringField(value: self.endpoint, fieldNumber: 1)
    }
    if !self.clientID.isEmpty {
      try visitor.visitSingularStringField(value: self.clientID, fieldNumber: 2)
    }
    if !self.clientSecret.isEmpty {
      try visitor.visitSingularStringField(value: self.clientSecret, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Sinch_Conversationapi_Type_ClientCredentials, rhs: Sinch_Conversationapi_Type_ClientCredentials) -> Bool {
    if lhs.endpoint != rhs.endpoint {return false}
    if lhs.clientID != rhs.clientID {return false}
    if lhs.clientSecret != rhs.clientSecret {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}
