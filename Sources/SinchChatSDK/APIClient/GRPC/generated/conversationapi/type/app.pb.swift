// DO NOT EDIT.
// swift-format-ignore-file
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: sinch/conversationapi/type/app.proto
//
// For information on using the generated types, please see the documentation:
//   https://github.com/apple/swift-protobuf/

import Foundation
import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that you are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

enum Sinch_Conversationapi_Type_ConversationMetadataReportView: SwiftProtobuf.Enum {
  typealias RawValue = Int

  /// Omit metadata
  case none // = 0

  /// Include all metadata assigned to the conversation
  case full // = 1
  case UNRECOGNIZED(Int)

  init() {
    self = .none
  }

  init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .none
    case 1: self = .full
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  var rawValue: Int {
    switch self {
    case .none: return 0
    case .full: return 1
    case .UNRECOGNIZED(let i): return i
    }
  }

}

#if swift(>=4.2)

extension Sinch_Conversationapi_Type_ConversationMetadataReportView: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  static var allCases: [Sinch_Conversationapi_Type_ConversationMetadataReportView] = [
    .none,
    .full,
  ]
}

#endif  // swift(>=4.2)

enum Sinch_Conversationapi_Type_RetentionPolicyType: SwiftProtobuf.Enum {
  typealias RawValue = Int

  /// The default retention policy where messages older than
  /// ttl_days are automatically deleted from Conversation API database. 
  case messageExpirePolicy // = 0

  /// The conversation expire policy only considers the last message in a conversation.
  /// If the last message is older that ttl_days the entire conversation is deleted.
  /// The difference with MESSAGE_EXPIRE_POLICY is that messages with accept_time
  /// older than ttl_days are persisted as long as there is a newer message in the
  /// same conversation. 
  case conversationExpirePolicy // = 1

  /// Persist policy does not delete old messages or conversations.
  /// Please note that message storage might be subject to additional charges
  /// in the future. 
  case persistRetentionPolicy // = 2
  case UNRECOGNIZED(Int)

  init() {
    self = .messageExpirePolicy
  }

  init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .messageExpirePolicy
    case 1: self = .conversationExpirePolicy
    case 2: self = .persistRetentionPolicy
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  var rawValue: Int {
    switch self {
    case .messageExpirePolicy: return 0
    case .conversationExpirePolicy: return 1
    case .persistRetentionPolicy: return 2
    case .UNRECOGNIZED(let i): return i
    }
  }

}

#if swift(>=4.2)

extension Sinch_Conversationapi_Type_RetentionPolicyType: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  static var allCases: [Sinch_Conversationapi_Type_RetentionPolicyType] = [
    .messageExpirePolicy,
    .conversationExpirePolicy,
    .persistRetentionPolicy,
  ]
}

#endif  // swift(>=4.2)

/// Conversation API app
///
/// The app corresponds to the API user and is a collection of channel credentials
/// allowing access to the underlying messaging channels.
/// The app is tied to a set of webhooks which define the destination for various events coming from the Conversation API.
struct Sinch_Conversationapi_Type_App {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Required. The ID of the app.
  var id: String = String()

  /// Channel credentials.
  /// The order of the credentials defines the
  /// app channel priority. 
  var channelCredentials: [Sinch_Conversationapi_Type_ConversationChannelCredential] = []

  /// Optional. A flag specifying whether to return conversation metadata as
  /// part of each callback. If omitted NONE will be used. 
  var conversationMetadataReportView: Sinch_Conversationapi_Type_ConversationMetadataReportView = .none

  /// Required. Human readable identifier of the app. E.g. Sinch Conversation API Demo App 001.
  var displayName: String = String()

  /// Output only. Rate limits associated with the app. Contact your account manager to change these.
  var rateLimits: Sinch_Conversationapi_Type_RateLimits {
    get {return _rateLimits ?? Sinch_Conversationapi_Type_RateLimits()}
    set {_rateLimits = newValue}
  }
  /// Returns true if `rateLimits` has been explicitly set.
  var hasRateLimits: Bool {return self._rateLimits != nil}
  /// Clears the value of `rateLimits`. Subsequent reads from it will return its default value.
  mutating func clearRateLimits() {self._rateLimits = nil}

  /// Optional. Defines the retention policy for messages and conversations.
  var retentionPolicy: Sinch_Conversationapi_Type_RetentionPolicy {
    get {return _retentionPolicy ?? Sinch_Conversationapi_Type_RetentionPolicy()}
    set {_retentionPolicy = newValue}
  }
  /// Returns true if `retentionPolicy` has been explicitly set.
  var hasRetentionPolicy: Bool {return self._retentionPolicy != nil}
  /// Clears the value of `retentionPolicy`. Subsequent reads from it will return its default value.
  mutating func clearRetentionPolicy() {self._retentionPolicy = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _rateLimits: Sinch_Conversationapi_Type_RateLimits? = nil
  fileprivate var _retentionPolicy: Sinch_Conversationapi_Type_RetentionPolicy? = nil
}

struct Sinch_Conversationapi_Type_RateLimits {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Output only. The number of messages/events we process per second, from the
  /// app to the underlying channels. Note that underlying channels may have other
  /// rate limits.  The default rate limit is 25.
  var outbound: UInt32 = 0

  /// Output only. The number of inbound messages/events we process per second,
  /// from underlying channels to the app.  The default rate limit is 25.
  var inbound: UInt32 = 0

  /// Output only. The rate limit of callbacks sent to the webhooks registered
  /// for the app. Note that if you have multiple webhooks with shared triggers,
  /// multiple callbacks will be sent out for each triggering event. The default rate limit is 25.
  var webhooks: UInt32 = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// Retention policy for messages and conversations
struct Sinch_Conversationapi_Type_RetentionPolicy {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Optional. Whether or not old messages or conversations are automatically deleted. 
  var retentionType: Sinch_Conversationapi_Type_RetentionPolicyType = .messageExpirePolicy

  /// Optional. The days before a message or conversation is eligible for deletion.
  /// Default value is 180. The ttl_days value has no effect when retention_type
  /// is PERSIST_RETENTION_POLICY. The valid values for this field are [1 - 3650].
  /// Note that retention cleanup job runs once every twenty-four hours
  /// which can lead to delay i.e., messages and conversations are not deleted on
  /// the minute they become eligible for deletion. 
  var ttlDays: UInt32 = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

// MARK: - Code below here is support for the SwiftProtobuf runtime.

fileprivate let _protobuf_package = "sinch.conversationapi.type"

extension Sinch_Conversationapi_Type_ConversationMetadataReportView: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "NONE"),
    1: .same(proto: "FULL"),
  ]
}

extension Sinch_Conversationapi_Type_RetentionPolicyType: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "MESSAGE_EXPIRE_POLICY"),
    1: .same(proto: "CONVERSATION_EXPIRE_POLICY"),
    2: .same(proto: "PERSIST_RETENTION_POLICY"),
  ]
}

extension Sinch_Conversationapi_Type_App: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".App"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "id"),
    2: .standard(proto: "channel_credentials"),
    3: .standard(proto: "conversation_metadata_report_view"),
    4: .standard(proto: "display_name"),
    5: .standard(proto: "rate_limits"),
    6: .standard(proto: "retention_policy"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.id) }()
      case 2: try { try decoder.decodeRepeatedMessageField(value: &self.channelCredentials) }()
      case 3: try { try decoder.decodeSingularEnumField(value: &self.conversationMetadataReportView) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.displayName) }()
      case 5: try { try decoder.decodeSingularMessageField(value: &self._rateLimits) }()
      case 6: try { try decoder.decodeSingularMessageField(value: &self._retentionPolicy) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.id.isEmpty {
      try visitor.visitSingularStringField(value: self.id, fieldNumber: 1)
    }
    if !self.channelCredentials.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.channelCredentials, fieldNumber: 2)
    }
    if self.conversationMetadataReportView != .none {
      try visitor.visitSingularEnumField(value: self.conversationMetadataReportView, fieldNumber: 3)
    }
    if !self.displayName.isEmpty {
      try visitor.visitSingularStringField(value: self.displayName, fieldNumber: 4)
    }
    try { if let v = self._rateLimits {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
    } }()
    try { if let v = self._retentionPolicy {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Sinch_Conversationapi_Type_App, rhs: Sinch_Conversationapi_Type_App) -> Bool {
    if lhs.id != rhs.id {return false}
    if lhs.channelCredentials != rhs.channelCredentials {return false}
    if lhs.conversationMetadataReportView != rhs.conversationMetadataReportView {return false}
    if lhs.displayName != rhs.displayName {return false}
    if lhs._rateLimits != rhs._rateLimits {return false}
    if lhs._retentionPolicy != rhs._retentionPolicy {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Sinch_Conversationapi_Type_RateLimits: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".RateLimits"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "outbound"),
    2: .same(proto: "inbound"),
    3: .same(proto: "webhooks"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt32Field(value: &self.outbound) }()
      case 2: try { try decoder.decodeSingularUInt32Field(value: &self.inbound) }()
      case 3: try { try decoder.decodeSingularUInt32Field(value: &self.webhooks) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.outbound != 0 {
      try visitor.visitSingularUInt32Field(value: self.outbound, fieldNumber: 1)
    }
    if self.inbound != 0 {
      try visitor.visitSingularUInt32Field(value: self.inbound, fieldNumber: 2)
    }
    if self.webhooks != 0 {
      try visitor.visitSingularUInt32Field(value: self.webhooks, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Sinch_Conversationapi_Type_RateLimits, rhs: Sinch_Conversationapi_Type_RateLimits) -> Bool {
    if lhs.outbound != rhs.outbound {return false}
    if lhs.inbound != rhs.inbound {return false}
    if lhs.webhooks != rhs.webhooks {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Sinch_Conversationapi_Type_RetentionPolicy: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".RetentionPolicy"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "retention_type"),
    2: .standard(proto: "ttl_days"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.retentionType) }()
      case 2: try { try decoder.decodeSingularUInt32Field(value: &self.ttlDays) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.retentionType != .messageExpirePolicy {
      try visitor.visitSingularEnumField(value: self.retentionType, fieldNumber: 1)
    }
    if self.ttlDays != 0 {
      try visitor.visitSingularUInt32Field(value: self.ttlDays, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Sinch_Conversationapi_Type_RetentionPolicy, rhs: Sinch_Conversationapi_Type_RetentionPolicy) -> Bool {
    if lhs.retentionType != rhs.retentionType {return false}
    if lhs.ttlDays != rhs.ttlDays {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}
