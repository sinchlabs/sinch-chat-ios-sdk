// DO NOT EDIT.
// swift-format-ignore-file
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: sinch/conversationapi/type/conversation_message.proto
//
// For information on using the generated types, please see the documentation:
//   https://github.com/apple/swift-protobuf/

import Foundation
import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that you are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

enum Sinch_Conversationapi_Type_ConversationDirection: SwiftProtobuf.Enum {
  typealias RawValue = Int
  case undefinedDirection // = 0
  case toApp // = 1
  case toContact // = 2
  case UNRECOGNIZED(Int)

  init() {
    self = .undefinedDirection
  }

  init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .undefinedDirection
    case 1: self = .toApp
    case 2: self = .toContact
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  var rawValue: Int {
    switch self {
    case .undefinedDirection: return 0
    case .toApp: return 1
    case .toContact: return 2
    case .UNRECOGNIZED(let i): return i
    }
  }

}

#if swift(>=4.2)

extension Sinch_Conversationapi_Type_ConversationDirection: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  static var allCases: [Sinch_Conversationapi_Type_ConversationDirection] = [
    .undefinedDirection,
    .toApp,
    .toContact,
  ]
}

#endif  // swift(>=4.2)

enum Sinch_Conversationapi_Type_CardHeight: SwiftProtobuf.Enum {
  typealias RawValue = Int
  case unspecifiedHeight // = 0
  case short // = 1
  case medium // = 2
  case tall // = 3
  case UNRECOGNIZED(Int)

  init() {
    self = .unspecifiedHeight
  }

  init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .unspecifiedHeight
    case 1: self = .short
    case 2: self = .medium
    case 3: self = .tall
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  var rawValue: Int {
    switch self {
    case .unspecifiedHeight: return 0
    case .short: return 1
    case .medium: return 2
    case .tall: return 3
    case .UNRECOGNIZED(let i): return i
    }
  }

}

#if swift(>=4.2)

extension Sinch_Conversationapi_Type_CardHeight: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  static var allCases: [Sinch_Conversationapi_Type_CardHeight] = [
    .unspecifiedHeight,
    .short,
    .medium,
    .tall,
  ]
}

#endif  // swift(>=4.2)

/// Conversation Message
///
/// A message on a particular channel.
struct Sinch_Conversationapi_Type_ConversationMessage {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Required. The ID of the message.
  var id: String = String()

  /// The direction defines what is the source and
  /// what is the destination of the message. 
  var direction: Sinch_Conversationapi_Type_ConversationDirection = .undefinedDirection

  /// The content of the message.
  var message: Sinch_Conversationapi_Type_ConversationMessage.OneOf_Message? = nil

  var appMessage: Sinch_Conversationapi_Type_AppMessage {
    get {
      if case .appMessage(let v)? = message {return v}
      return Sinch_Conversationapi_Type_AppMessage()
    }
    set {message = .appMessage(newValue)}
  }

  var contactMessage: Sinch_Conversationapi_Type_ContactMessage {
    get {
      if case .contactMessage(let v)? = message {return v}
      return Sinch_Conversationapi_Type_ContactMessage()
    }
    set {message = .contactMessage(newValue)}
  }

  /// Required. The channel and contact channel identity of the message.
  var channelIdentity: Sinch_Conversationapi_Type_ChannelIdentity {
    get {return _channelIdentity ?? Sinch_Conversationapi_Type_ChannelIdentity()}
    set {_channelIdentity = newValue}
  }
  /// Returns true if `channelIdentity` has been explicitly set.
  var hasChannelIdentity: Bool {return self._channelIdentity != nil}
  /// Clears the value of `channelIdentity`. Subsequent reads from it will return its default value.
  mutating func clearChannelIdentity() {self._channelIdentity = nil}

  /// Required. The ID of the conversation.
  var conversationID: String = String()

  /// Required. The ID of the contact.
  var contactID: String = String()

  /// Optional. Metadata associated with the contact.
  /// Up to 1024 characters long. 
  var metadata: String = String()

  /// Output only.
  var acceptTime: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _acceptTime ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_acceptTime = newValue}
  }
  /// Returns true if `acceptTime` has been explicitly set.
  var hasAcceptTime: Bool {return self._acceptTime != nil}
  /// Clears the value of `acceptTime`. Subsequent reads from it will return its default value.
  mutating func clearAcceptTime() {self._acceptTime = nil}

  /// Optional. For Contact Messages the sender ID that the contact
  /// sent the message to. For App Messages the sender that was
  /// used to send the message, if applicable.
  var senderID: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  /// The content of the message.
  enum OneOf_Message: Equatable {
    case appMessage(Sinch_Conversationapi_Type_AppMessage)
    case contactMessage(Sinch_Conversationapi_Type_ContactMessage)

  #if !swift(>=4.1)
    static func ==(lhs: Sinch_Conversationapi_Type_ConversationMessage.OneOf_Message, rhs: Sinch_Conversationapi_Type_ConversationMessage.OneOf_Message) -> Bool {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch (lhs, rhs) {
      case (.appMessage, .appMessage): return {
        guard case .appMessage(let l) = lhs, case .appMessage(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.contactMessage, .contactMessage): return {
        guard case .contactMessage(let l) = lhs, case .contactMessage(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      default: return false
      }
    }
  #endif
  }

  init() {}

  fileprivate var _channelIdentity: Sinch_Conversationapi_Type_ChannelIdentity? = nil
  fileprivate var _acceptTime: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
}

/// Message originating from an app
struct Sinch_Conversationapi_Type_AppMessage {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Optional. Channel specific messages, overriding any transcoding.
  /// The key in the map must point to a valid conversation channel as
  /// defined by the enum ConversationChannel. 
  var explicitChannelMessage: Dictionary<String,String> {
    get {return _storage._explicitChannelMessage}
    set {_uniqueStorage()._explicitChannelMessage = newValue}
  }

  /// The content of the message.
  /// One of TextMessage, MediaMessage,
  /// TemplateMessage, ChoiceMessage,
  /// CardMessage, CarouselMessage, 
  /// LocationMessage or ContactInfoMessage. 
  var message: OneOf_Message? {
    get {return _storage._message}
    set {_uniqueStorage()._message = newValue}
  }

  /// A message containing only text.
  var textMessage: Sinch_Conversationapi_Type_TextMessage {
    get {
      if case .textMessage(let v)? = _storage._message {return v}
      return Sinch_Conversationapi_Type_TextMessage()
    }
    set {_uniqueStorage()._message = .textMessage(newValue)}
  }

  /// A message containing media such as images, GIFs, and video.
  var mediaMessage: Sinch_Conversationapi_Type_MediaMessage {
    get {
      if case .mediaMessage(let v)? = _storage._message {return v}
      return Sinch_Conversationapi_Type_MediaMessage()
    }
    set {_uniqueStorage()._message = .mediaMessage(newValue)}
  }

  /// A message with predefined template.
  /// Requires an existing template. 
  var templateMessage: Sinch_Conversationapi_Type_TemplateMessage {
    get {
      if case .templateMessage(let v)? = _storage._message {return v}
      return Sinch_Conversationapi_Type_TemplateMessage()
    }
    set {_uniqueStorage()._message = .templateMessage(newValue)}
  }

  /// A message containing a "choice"/"action" and description.
  /// A choice message is transcoded as a button in Messenger and RCS
  /// and as a bullet point in SMS and WhatsApp. 
  var choiceMessage: Sinch_Conversationapi_Type_ChoiceMessage {
    get {
      if case .choiceMessage(let v)? = _storage._message {return v}
      return Sinch_Conversationapi_Type_ChoiceMessage()
    }
    set {_uniqueStorage()._message = .choiceMessage(newValue)}
  }

  /// A rich message which consists of text and description with image or video.
  /// It can also contain a set of "choices" ("actions"). 
  var cardMessage: Sinch_Conversationapi_Type_CardMessage {
    get {
      if case .cardMessage(let v)? = _storage._message {return v}
      return Sinch_Conversationapi_Type_CardMessage()
    }
    set {_uniqueStorage()._message = .cardMessage(newValue)}
  }

  /// A list of cards rendered horizontally on supported channels (Messenger and RCS)
  /// and as a numbered list on SMS and WhatsApp. 
  var carouselMessage: Sinch_Conversationapi_Type_CarouselMessage {
    get {
      if case .carouselMessage(let v)? = _storage._message {return v}
      return Sinch_Conversationapi_Type_CarouselMessage()
    }
    set {_uniqueStorage()._message = .carouselMessage(newValue)}
  }

  /// A message defining a physical location on a map.
  var locationMessage: Sinch_Conversationapi_Type_LocationMessage {
    get {
      if case .locationMessage(let v)? = _storage._message {return v}
      return Sinch_Conversationapi_Type_LocationMessage()
    }
    set {_uniqueStorage()._message = .locationMessage(newValue)}
  }

  /// A message containing contact information. 
  var contactInfoMessage: Sinch_Conversationapi_Type_ContactInfoMessage {
    get {
      if case .contactInfoMessage(let v)? = _storage._message {return v}
      return Sinch_Conversationapi_Type_ContactInfoMessage()
    }
    set {_uniqueStorage()._message = .contactInfoMessage(newValue)}
  }

  /// Optional identity of an sender
  var agent: Sinch_Conversationapi_Type_Agent {
    get {return _storage._agent ?? Sinch_Conversationapi_Type_Agent()}
    set {_uniqueStorage()._agent = newValue}
  }
  /// Returns true if `agent` has been explicitly set.
  var hasAgent: Bool {return _storage._agent != nil}
  /// Clears the value of `agent`. Subsequent reads from it will return its default value.
  mutating func clearAgent() {_uniqueStorage()._agent = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  /// The content of the message.
  /// One of TextMessage, MediaMessage,
  /// TemplateMessage, ChoiceMessage,
  /// CardMessage, CarouselMessage, 
  /// LocationMessage or ContactInfoMessage. 
  enum OneOf_Message: Equatable {
    /// A message containing only text.
    case textMessage(Sinch_Conversationapi_Type_TextMessage)
    /// A message containing media such as images, GIFs, and video.
    case mediaMessage(Sinch_Conversationapi_Type_MediaMessage)
    /// A message with predefined template.
    /// Requires an existing template. 
    case templateMessage(Sinch_Conversationapi_Type_TemplateMessage)
    /// A message containing a "choice"/"action" and description.
    /// A choice message is transcoded as a button in Messenger and RCS
    /// and as a bullet point in SMS and WhatsApp. 
    case choiceMessage(Sinch_Conversationapi_Type_ChoiceMessage)
    /// A rich message which consists of text and description with image or video.
    /// It can also contain a set of "choices" ("actions"). 
    case cardMessage(Sinch_Conversationapi_Type_CardMessage)
    /// A list of cards rendered horizontally on supported channels (Messenger and RCS)
    /// and as a numbered list on SMS and WhatsApp. 
    case carouselMessage(Sinch_Conversationapi_Type_CarouselMessage)
    /// A message defining a physical location on a map.
    case locationMessage(Sinch_Conversationapi_Type_LocationMessage)
    /// A message containing contact information. 
    case contactInfoMessage(Sinch_Conversationapi_Type_ContactInfoMessage)

  #if !swift(>=4.1)
    static func ==(lhs: Sinch_Conversationapi_Type_AppMessage.OneOf_Message, rhs: Sinch_Conversationapi_Type_AppMessage.OneOf_Message) -> Bool {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch (lhs, rhs) {
      case (.textMessage, .textMessage): return {
        guard case .textMessage(let l) = lhs, case .textMessage(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.mediaMessage, .mediaMessage): return {
        guard case .mediaMessage(let l) = lhs, case .mediaMessage(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.templateMessage, .templateMessage): return {
        guard case .templateMessage(let l) = lhs, case .templateMessage(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.choiceMessage, .choiceMessage): return {
        guard case .choiceMessage(let l) = lhs, case .choiceMessage(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.cardMessage, .cardMessage): return {
        guard case .cardMessage(let l) = lhs, case .cardMessage(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.carouselMessage, .carouselMessage): return {
        guard case .carouselMessage(let l) = lhs, case .carouselMessage(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.locationMessage, .locationMessage): return {
        guard case .locationMessage(let l) = lhs, case .locationMessage(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.contactInfoMessage, .contactInfoMessage): return {
        guard case .contactInfoMessage(let l) = lhs, case .contactInfoMessage(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      default: return false
      }
    }
  #endif
  }

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

/// Message originating from a contact
struct Sinch_Conversationapi_Type_ContactMessage {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var message: Sinch_Conversationapi_Type_ContactMessage.OneOf_Message? = nil

  var textMessage: Sinch_Conversationapi_Type_TextMessage {
    get {
      if case .textMessage(let v)? = message {return v}
      return Sinch_Conversationapi_Type_TextMessage()
    }
    set {message = .textMessage(newValue)}
  }

  var mediaMessage: Sinch_Conversationapi_Type_MediaMessage {
    get {
      if case .mediaMessage(let v)? = message {return v}
      return Sinch_Conversationapi_Type_MediaMessage()
    }
    set {message = .mediaMessage(newValue)}
  }

  var locationMessage: Sinch_Conversationapi_Type_LocationMessage {
    get {
      if case .locationMessage(let v)? = message {return v}
      return Sinch_Conversationapi_Type_LocationMessage()
    }
    set {message = .locationMessage(newValue)}
  }

  var choiceResponseMessage: Sinch_Conversationapi_Type_ChoiceResponseMessage {
    get {
      if case .choiceResponseMessage(let v)? = message {return v}
      return Sinch_Conversationapi_Type_ChoiceResponseMessage()
    }
    set {message = .choiceResponseMessage(newValue)}
  }

  var mediaCardMessage: Sinch_Conversationapi_Type_MediaCardMessage {
    get {
      if case .mediaCardMessage(let v)? = message {return v}
      return Sinch_Conversationapi_Type_MediaCardMessage()
    }
    set {message = .mediaCardMessage(newValue)}
  }

  var fallbackMessage: Sinch_Conversationapi_Type_FallbackMessage {
    get {
      if case .fallbackMessage(let v)? = message {return v}
      return Sinch_Conversationapi_Type_FallbackMessage()
    }
    set {message = .fallbackMessage(newValue)}
  }

  ///Optional. Included if the contact message is a response to a previous App message.
  var replyTo: Sinch_Conversationapi_Type_ReplyTo {
    get {return _replyTo ?? Sinch_Conversationapi_Type_ReplyTo()}
    set {_replyTo = newValue}
  }
  /// Returns true if `replyTo` has been explicitly set.
  var hasReplyTo: Bool {return self._replyTo != nil}
  /// Clears the value of `replyTo`. Subsequent reads from it will return its default value.
  mutating func clearReplyTo() {self._replyTo = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  enum OneOf_Message: Equatable {
    case textMessage(Sinch_Conversationapi_Type_TextMessage)
    case mediaMessage(Sinch_Conversationapi_Type_MediaMessage)
    case locationMessage(Sinch_Conversationapi_Type_LocationMessage)
    case choiceResponseMessage(Sinch_Conversationapi_Type_ChoiceResponseMessage)
    case mediaCardMessage(Sinch_Conversationapi_Type_MediaCardMessage)
    case fallbackMessage(Sinch_Conversationapi_Type_FallbackMessage)

  #if !swift(>=4.1)
    static func ==(lhs: Sinch_Conversationapi_Type_ContactMessage.OneOf_Message, rhs: Sinch_Conversationapi_Type_ContactMessage.OneOf_Message) -> Bool {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch (lhs, rhs) {
      case (.textMessage, .textMessage): return {
        guard case .textMessage(let l) = lhs, case .textMessage(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.mediaMessage, .mediaMessage): return {
        guard case .mediaMessage(let l) = lhs, case .mediaMessage(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.locationMessage, .locationMessage): return {
        guard case .locationMessage(let l) = lhs, case .locationMessage(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.choiceResponseMessage, .choiceResponseMessage): return {
        guard case .choiceResponseMessage(let l) = lhs, case .choiceResponseMessage(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.mediaCardMessage, .mediaCardMessage): return {
        guard case .mediaCardMessage(let l) = lhs, case .mediaCardMessage(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.fallbackMessage, .fallbackMessage): return {
        guard case .fallbackMessage(let l) = lhs, case .fallbackMessage(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      default: return false
      }
    }
  #endif
  }

  init() {}

  fileprivate var _replyTo: Sinch_Conversationapi_Type_ReplyTo? = nil
}

/// Message containing only text
struct Sinch_Conversationapi_Type_TextMessage {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Required. The text to be sent.
  var text: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// Message containing media
struct Sinch_Conversationapi_Type_MediaMessage {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Required. Url to the file.
  var url: String = String()

  ///Optional. Will be used where it is natively supported
  var thumbnailURL: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// Contact Message containing media and caption
struct Sinch_Conversationapi_Type_MediaCardMessage {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Required. Url to the file.
  var url: String = String()

  /// Optional. Caption for the media on channels, where its supported.
  var caption: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// Fallback message, appears when original contact message can not be handled
struct Sinch_Conversationapi_Type_FallbackMessage {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Required. The Reason the fallback message was returned instead of original one.
  var reason: Sinch_Conversationapi_Type_Reason {
    get {return _reason ?? Sinch_Conversationapi_Type_Reason()}
    set {_reason = newValue}
  }
  /// Returns true if `reason` has been explicitly set.
  var hasReason: Bool {return self._reason != nil}
  /// Clears the value of `reason`. Subsequent reads from it will return its default value.
  mutating func clearReason() {self._reason = nil}

  /// Optional. The raw fallback message if provided by the channel.
  var rawMessage: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _reason: Sinch_Conversationapi_Type_Reason? = nil
}

/// Message referring to predefined template
struct Sinch_Conversationapi_Type_TemplateMessage {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Optional. Channel specific template reference with parameters per channel.
  /// The channel template if exists overrides the omnichannel template.
  /// At least one of channel_template or omni_template needs to be present.
  /// The key in the map must point to a valid conversation channel as
  /// defined by the enum ConversationChannel. 
  var channelTemplate: Dictionary<String,Sinch_Conversationapi_Type_TemplateReference> = [:]

  /// Optional. Omnichannel template stored in Conversation API Template Store
  /// as AppMessage. At least one of channel_template or omni_template needs to be present. 
  var omniTemplate: Sinch_Conversationapi_Type_TemplateReference {
    get {return _omniTemplate ?? Sinch_Conversationapi_Type_TemplateReference()}
    set {_omniTemplate = newValue}
  }
  /// Returns true if `omniTemplate` has been explicitly set.
  var hasOmniTemplate: Bool {return self._omniTemplate != nil}
  /// Clears the value of `omniTemplate`. Subsequent reads from it will return its default value.
  mutating func clearOmniTemplate() {self._omniTemplate = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _omniTemplate: Sinch_Conversationapi_Type_TemplateReference? = nil
}

/// Template reference with concrete parameter values
///
/// The referenced template can be an omnichannel template
/// stored in Conversation API Template Store as AppMessage
/// or it can reference external channel-specific template
/// such as WhatsApp Business Template. 
struct Sinch_Conversationapi_Type_TemplateReference {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Required. The ID of the template.
  var templateID: String = String()

  /// Required for omnichannel template. Optional for channel template.
  /// Used to specify what version of a template to use.
  /// This will be used in conjunction with language_code. 
  var version: String = String()

  /// Optional. The BCP-47 language code, such as "en-US" or "sr-Latn".
  /// For more information, see http://www.unicode.org/reports/tr35/#Unicode_locale_identifier.
  /// English is the default language_code. 
  var languageCode: String = String()

  /// Optional. Required if the template
  /// has parameters. Concrete values must
  /// be present for all defined parameters
  /// in the template. Parameters can be different for
  /// different versions and/or languages of the template. 
  var parameters: Dictionary<String,String> = [:]

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// Message with geo location
struct Sinch_Conversationapi_Type_LocationMessage {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Required. The title is shown close to the
  /// button or link that leads to a map showing the location.
  /// The title is clickable in some cases. 
  var title: String = String()

  /// Required. Geo coordinates.
  var coordinates: Sinch_Conversationapi_Type_Coordinates {
    get {return _coordinates ?? Sinch_Conversationapi_Type_Coordinates()}
    set {_coordinates = newValue}
  }
  /// Returns true if `coordinates` has been explicitly set.
  var hasCoordinates: Bool {return self._coordinates != nil}
  /// Clears the value of `coordinates`. Subsequent reads from it will return its default value.
  mutating func clearCoordinates() {self._coordinates = nil}

  /// Optional. Label or name for the position.
  var label: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _coordinates: Sinch_Conversationapi_Type_Coordinates? = nil
}

/// Choice/Action
///
/// A choice is an action the user can take such as
/// buttons for quick replies, call actions etc. 
struct Sinch_Conversationapi_Type_Choice {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Required. The choice content.
  var choice: Sinch_Conversationapi_Type_Choice.OneOf_Choice? = nil

  var textMessage: Sinch_Conversationapi_Type_TextMessage {
    get {
      if case .textMessage(let v)? = choice {return v}
      return Sinch_Conversationapi_Type_TextMessage()
    }
    set {choice = .textMessage(newValue)}
  }

  var urlMessage: Sinch_Conversationapi_Type_UrlMessage {
    get {
      if case .urlMessage(let v)? = choice {return v}
      return Sinch_Conversationapi_Type_UrlMessage()
    }
    set {choice = .urlMessage(newValue)}
  }

  var callMessage: Sinch_Conversationapi_Type_CallMessage {
    get {
      if case .callMessage(let v)? = choice {return v}
      return Sinch_Conversationapi_Type_CallMessage()
    }
    set {choice = .callMessage(newValue)}
  }

  var locationMessage: Sinch_Conversationapi_Type_LocationMessage {
    get {
      if case .locationMessage(let v)? = choice {return v}
      return Sinch_Conversationapi_Type_LocationMessage()
    }
    set {choice = .locationMessage(newValue)}
  }

  /// Optional. This data will be returned in the ChoiceResponseMessage.
  /// The default is message_id_{text, title}. 
  var postbackData: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  /// Required. The choice content.
  enum OneOf_Choice: Equatable {
    case textMessage(Sinch_Conversationapi_Type_TextMessage)
    case urlMessage(Sinch_Conversationapi_Type_UrlMessage)
    case callMessage(Sinch_Conversationapi_Type_CallMessage)
    case locationMessage(Sinch_Conversationapi_Type_LocationMessage)

  #if !swift(>=4.1)
    static func ==(lhs: Sinch_Conversationapi_Type_Choice.OneOf_Choice, rhs: Sinch_Conversationapi_Type_Choice.OneOf_Choice) -> Bool {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch (lhs, rhs) {
      case (.textMessage, .textMessage): return {
        guard case .textMessage(let l) = lhs, case .textMessage(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.urlMessage, .urlMessage): return {
        guard case .urlMessage(let l) = lhs, case .urlMessage(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.callMessage, .callMessage): return {
        guard case .callMessage(let l) = lhs, case .callMessage(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.locationMessage, .locationMessage): return {
        guard case .locationMessage(let l) = lhs, case .locationMessage(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      default: return false
      }
    }
  #endif
  }

  init() {}
}

/// Call Message
///
/// Message for triggering a call. 
struct Sinch_Conversationapi_Type_CallMessage {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Required. Title shown close to the phone number.
  /// The title is clickable in some cases. 
  var title: String = String()

  /// Required. Phone number in E.164 with leading +.
  var phoneNumber: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// Choice Message
///
/// Message containing choices/actions. 
struct Sinch_Conversationapi_Type_ChoiceMessage {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Required.
  var textMessage: Sinch_Conversationapi_Type_TextMessage {
    get {return _textMessage ?? Sinch_Conversationapi_Type_TextMessage()}
    set {_textMessage = newValue}
  }
  /// Returns true if `textMessage` has been explicitly set.
  var hasTextMessage: Bool {return self._textMessage != nil}
  /// Clears the value of `textMessage`. Subsequent reads from it will return its default value.
  mutating func clearTextMessage() {self._textMessage = nil}

  /// Required. The number of choices is limited to 3.
  var choices: [Sinch_Conversationapi_Type_Choice] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _textMessage: Sinch_Conversationapi_Type_TextMessage? = nil
}

/// Card Message
///
/// Message containing text, media and choices. 
struct Sinch_Conversationapi_Type_CardMessage {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Required.
  var title: String = String()

  /// Optional.
  var description_p: String = String()

  /// Optional.
  var mediaMessage: Sinch_Conversationapi_Type_MediaMessage {
    get {return _mediaMessage ?? Sinch_Conversationapi_Type_MediaMessage()}
    set {_mediaMessage = newValue}
  }
  /// Returns true if `mediaMessage` has been explicitly set.
  var hasMediaMessage: Bool {return self._mediaMessage != nil}
  /// Clears the value of `mediaMessage`. Subsequent reads from it will return its default value.
  mutating func clearMediaMessage() {self._mediaMessage = nil}

  /// Optional. The number of choices is limited to 3. 
  var choices: [Sinch_Conversationapi_Type_Choice] = []

  /// Optional. Will be used where it is natively supported
  var height: Sinch_Conversationapi_Type_CardHeight = .unspecifiedHeight

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _mediaMessage: Sinch_Conversationapi_Type_MediaMessage? = nil
}

/// Carousel Message
///
/// Message containing a list of cards often
/// rendered horizontally on supported channels. Supported
/// types for media are only images, e.g. .png, .jpg, .jpeg
/// extensions. 
struct Sinch_Conversationapi_Type_CarouselMessage {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Required. A list of 1..10 cards.
  var cards: [Sinch_Conversationapi_Type_CardMessage] = []

  /// Optional. Outer choices on the carousel level.
  /// The number of outer choices is limited to 3. 
  var choices: [Sinch_Conversationapi_Type_Choice] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// Choice Response Message
///
/// Represents a response to a choice message. 
struct Sinch_Conversationapi_Type_ChoiceResponseMessage {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Required. The message id containing the choice.
  var messageID: String = String()

  /// Required. The postback_data defined in the selected choice.
  var postbackData: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// Url Message
///
/// A generic URL message. 
struct Sinch_Conversationapi_Type_UrlMessage {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Required. The title shown close to the URL.
  /// The title will be clickable in some cases. 
  var title: String = String()

  /// Required. The url to show.
  var url: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// Reply To
///
/// If the contact message was a response to a previous App message then this field contains information about that. 
struct Sinch_Conversationapi_Type_ReplyTo {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Required. The Id of the message that this is a response to
  var messageID: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// Contact Info Message
///
/// A generic Contact Info message, that speaks directly to the native mobile contacts app. 
struct Sinch_Conversationapi_Type_ContactInfoMessage {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Required. Name information of the contact.
  var name: Sinch_Conversationapi_Type_NameInfo {
    get {return _name ?? Sinch_Conversationapi_Type_NameInfo()}
    set {_name = newValue}
  }
  /// Returns true if `name` has been explicitly set.
  var hasName: Bool {return self._name != nil}
  /// Clears the value of `name`. Subsequent reads from it will return its default value.
  mutating func clearName() {self._name = nil}

  /// Required. Phone numbers of the contact.
  var phoneNumbers: [Sinch_Conversationapi_Type_PhoneNumberInfo] = []

  /// Optional. Physical addresses of the contact.
  var addresses: [Sinch_Conversationapi_Type_AddressInfo] = []

  /// Optional. Email addresses of the contact.
  var emailAddresses: [Sinch_Conversationapi_Type_EmailInfo] = []

  /// Optional. Organization information of the contact.
  var organization: Sinch_Conversationapi_Type_OrganizationInfo {
    get {return _organization ?? Sinch_Conversationapi_Type_OrganizationInfo()}
    set {_organization = newValue}
  }
  /// Returns true if `organization` has been explicitly set.
  var hasOrganization: Bool {return self._organization != nil}
  /// Clears the value of `organization`. Subsequent reads from it will return its default value.
  mutating func clearOrganization() {self._organization = nil}

  /// Optional. URLs/websites associated with the contact.
  var urls: [Sinch_Conversationapi_Type_UrlInfo] = []

  /// Optional. Date of birth.
  /// Format: "YYYY-MM-DD"
  var birthday: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _name: Sinch_Conversationapi_Type_NameInfo? = nil
  fileprivate var _organization: Sinch_Conversationapi_Type_OrganizationInfo? = nil
}

/// Address Info object
///
/// A physical address. 
struct Sinch_Conversationapi_Type_AddressInfo {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Optional. City name.
  var city: String = String()

  /// Optional. Country name.
  var country: String = String()

  /// Optional. Name of a state or region of a country.
  var state: String = String()

  /// Optional. Street name including street/apartment number.
  var street: String = String()

  /// Optional. Zip/postal code.
  var zip: String = String()

  /// Optional. Address type, e.g. WORK or HOME.
  var type: String = String()

  /// Optional. Two letter country code.
  /// Used for formatting. 
  var countryCode: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// Email Info object
///
/// An email address. 
struct Sinch_Conversationapi_Type_EmailInfo {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Required. Email address.
  var emailAddress: String = String()

  /// Optional. Email address type, e.g. WORK or HOME.
  var type: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// Name Info object
///
/// Name information. 
struct Sinch_Conversationapi_Type_NameInfo {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Required. Full name.
  /// Will be the displayed contact name. Format as desired. 
  var fullName: String = String()

  /// Optional. First name/given name.
  var firstName: String = String()

  /// Optional. Family name/last name/surname.
  var lastName: String = String()

  /// Optional. Middle name.
  var middleName: String = String()

  /// Optional. Prefix, e.g. Mr or Ms.
  var prefix: String = String()

  /// Optional. Suffix, e.g. Jr or PhD.
  var suffix: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// Organization Info object
///
/// Organization information. 
struct Sinch_Conversationapi_Type_OrganizationInfo {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Optional. Company name.
  var company: String = String()

  /// Optional. Department at the company.
  var department: String = String()

  /// Optional. Corporate title, e.g. software engineer.
  var title: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// Phone Number Info object
///
/// A Phone number. 
struct Sinch_Conversationapi_Type_PhoneNumberInfo {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Required. Phone number.
  /// Potential country codes included. 
  var phoneNumber: String = String()

  /// Optional. Phone number type, e.g. WORK or HOME.
  var type: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// URL Info
/// 
/// A URL/website. 
struct Sinch_Conversationapi_Type_UrlInfo {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Required. The URL to be referenced.
  var url: String = String()

  /// Optional. URL type, e.g. HOME or ORG. 
  var type: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

#if swift(>=5.5) && canImport(_Concurrency)
extension Sinch_Conversationapi_Type_ConversationDirection: @unchecked Sendable {}
extension Sinch_Conversationapi_Type_CardHeight: @unchecked Sendable {}
extension Sinch_Conversationapi_Type_ConversationMessage: @unchecked Sendable {}
extension Sinch_Conversationapi_Type_ConversationMessage.OneOf_Message: @unchecked Sendable {}
extension Sinch_Conversationapi_Type_AppMessage: @unchecked Sendable {}
extension Sinch_Conversationapi_Type_AppMessage.OneOf_Message: @unchecked Sendable {}
extension Sinch_Conversationapi_Type_ContactMessage: @unchecked Sendable {}
extension Sinch_Conversationapi_Type_ContactMessage.OneOf_Message: @unchecked Sendable {}
extension Sinch_Conversationapi_Type_TextMessage: @unchecked Sendable {}
extension Sinch_Conversationapi_Type_MediaMessage: @unchecked Sendable {}
extension Sinch_Conversationapi_Type_MediaCardMessage: @unchecked Sendable {}
extension Sinch_Conversationapi_Type_FallbackMessage: @unchecked Sendable {}
extension Sinch_Conversationapi_Type_TemplateMessage: @unchecked Sendable {}
extension Sinch_Conversationapi_Type_TemplateReference: @unchecked Sendable {}
extension Sinch_Conversationapi_Type_LocationMessage: @unchecked Sendable {}
extension Sinch_Conversationapi_Type_Choice: @unchecked Sendable {}
extension Sinch_Conversationapi_Type_Choice.OneOf_Choice: @unchecked Sendable {}
extension Sinch_Conversationapi_Type_CallMessage: @unchecked Sendable {}
extension Sinch_Conversationapi_Type_ChoiceMessage: @unchecked Sendable {}
extension Sinch_Conversationapi_Type_CardMessage: @unchecked Sendable {}
extension Sinch_Conversationapi_Type_CarouselMessage: @unchecked Sendable {}
extension Sinch_Conversationapi_Type_ChoiceResponseMessage: @unchecked Sendable {}
extension Sinch_Conversationapi_Type_UrlMessage: @unchecked Sendable {}
extension Sinch_Conversationapi_Type_ReplyTo: @unchecked Sendable {}
extension Sinch_Conversationapi_Type_ContactInfoMessage: @unchecked Sendable {}
extension Sinch_Conversationapi_Type_AddressInfo: @unchecked Sendable {}
extension Sinch_Conversationapi_Type_EmailInfo: @unchecked Sendable {}
extension Sinch_Conversationapi_Type_NameInfo: @unchecked Sendable {}
extension Sinch_Conversationapi_Type_OrganizationInfo: @unchecked Sendable {}
extension Sinch_Conversationapi_Type_PhoneNumberInfo: @unchecked Sendable {}
extension Sinch_Conversationapi_Type_UrlInfo: @unchecked Sendable {}
#endif  // swift(>=5.5) && canImport(_Concurrency)

// MARK: - Code below here is support for the SwiftProtobuf runtime.

fileprivate let _protobuf_package = "sinch.conversationapi.type"

extension Sinch_Conversationapi_Type_ConversationDirection: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "UNDEFINED_DIRECTION"),
    1: .same(proto: "TO_APP"),
    2: .same(proto: "TO_CONTACT"),
  ]
}

extension Sinch_Conversationapi_Type_CardHeight: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "UNSPECIFIED_HEIGHT"),
    1: .same(proto: "SHORT"),
    2: .same(proto: "MEDIUM"),
    3: .same(proto: "TALL"),
  ]
}

extension Sinch_Conversationapi_Type_ConversationMessage: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ConversationMessage"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "id"),
    2: .same(proto: "direction"),
    3: .standard(proto: "app_message"),
    4: .standard(proto: "contact_message"),
    5: .standard(proto: "channel_identity"),
    6: .standard(proto: "conversation_id"),
    7: .standard(proto: "contact_id"),
    8: .same(proto: "metadata"),
    9: .standard(proto: "accept_time"),
    10: .standard(proto: "sender_id"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.id) }()
      case 2: try { try decoder.decodeSingularEnumField(value: &self.direction) }()
      case 3: try {
        var v: Sinch_Conversationapi_Type_AppMessage?
        var hadOneofValue = false
        if let current = self.message {
          hadOneofValue = true
          if case .appMessage(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.message = .appMessage(v)
        }
      }()
      case 4: try {
        var v: Sinch_Conversationapi_Type_ContactMessage?
        var hadOneofValue = false
        if let current = self.message {
          hadOneofValue = true
          if case .contactMessage(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.message = .contactMessage(v)
        }
      }()
      case 5: try { try decoder.decodeSingularMessageField(value: &self._channelIdentity) }()
      case 6: try { try decoder.decodeSingularStringField(value: &self.conversationID) }()
      case 7: try { try decoder.decodeSingularStringField(value: &self.contactID) }()
      case 8: try { try decoder.decodeSingularStringField(value: &self.metadata) }()
      case 9: try { try decoder.decodeSingularMessageField(value: &self._acceptTime) }()
      case 10: try { try decoder.decodeSingularStringField(value: &self.senderID) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.id.isEmpty {
      try visitor.visitSingularStringField(value: self.id, fieldNumber: 1)
    }
    if self.direction != .undefinedDirection {
      try visitor.visitSingularEnumField(value: self.direction, fieldNumber: 2)
    }
    switch self.message {
    case .appMessage?: try {
      guard case .appMessage(let v)? = self.message else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    }()
    case .contactMessage?: try {
      guard case .contactMessage(let v)? = self.message else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    }()
    case nil: break
    }
    try { if let v = self._channelIdentity {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
    } }()
    if !self.conversationID.isEmpty {
      try visitor.visitSingularStringField(value: self.conversationID, fieldNumber: 6)
    }
    if !self.contactID.isEmpty {
      try visitor.visitSingularStringField(value: self.contactID, fieldNumber: 7)
    }
    if !self.metadata.isEmpty {
      try visitor.visitSingularStringField(value: self.metadata, fieldNumber: 8)
    }
    try { if let v = self._acceptTime {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 9)
    } }()
    if !self.senderID.isEmpty {
      try visitor.visitSingularStringField(value: self.senderID, fieldNumber: 10)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Sinch_Conversationapi_Type_ConversationMessage, rhs: Sinch_Conversationapi_Type_ConversationMessage) -> Bool {
    if lhs.id != rhs.id {return false}
    if lhs.direction != rhs.direction {return false}
    if lhs.message != rhs.message {return false}
    if lhs._channelIdentity != rhs._channelIdentity {return false}
    if lhs.conversationID != rhs.conversationID {return false}
    if lhs.contactID != rhs.contactID {return false}
    if lhs.metadata != rhs.metadata {return false}
    if lhs._acceptTime != rhs._acceptTime {return false}
    if lhs.senderID != rhs.senderID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Sinch_Conversationapi_Type_AppMessage: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".AppMessage"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "explicit_channel_message"),
    2: .standard(proto: "text_message"),
    3: .standard(proto: "media_message"),
    4: .standard(proto: "template_message"),
    5: .standard(proto: "choice_message"),
    6: .standard(proto: "card_message"),
    7: .standard(proto: "carousel_message"),
    8: .standard(proto: "location_message"),
    9: .standard(proto: "contact_info_message"),
    10: .same(proto: "agent"),
  ]

  fileprivate class _StorageClass {
    var _explicitChannelMessage: Dictionary<String,String> = [:]
    var _message: Sinch_Conversationapi_Type_AppMessage.OneOf_Message?
    var _agent: Sinch_Conversationapi_Type_Agent? = nil

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _explicitChannelMessage = source._explicitChannelMessage
      _message = source._message
      _agent = source._agent
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeMapField(fieldType: SwiftProtobuf._ProtobufMap<SwiftProtobuf.ProtobufString,SwiftProtobuf.ProtobufString>.self, value: &_storage._explicitChannelMessage) }()
        case 2: try {
          var v: Sinch_Conversationapi_Type_TextMessage?
          var hadOneofValue = false
          if let current = _storage._message {
            hadOneofValue = true
            if case .textMessage(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._message = .textMessage(v)
          }
        }()
        case 3: try {
          var v: Sinch_Conversationapi_Type_MediaMessage?
          var hadOneofValue = false
          if let current = _storage._message {
            hadOneofValue = true
            if case .mediaMessage(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._message = .mediaMessage(v)
          }
        }()
        case 4: try {
          var v: Sinch_Conversationapi_Type_TemplateMessage?
          var hadOneofValue = false
          if let current = _storage._message {
            hadOneofValue = true
            if case .templateMessage(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._message = .templateMessage(v)
          }
        }()
        case 5: try {
          var v: Sinch_Conversationapi_Type_ChoiceMessage?
          var hadOneofValue = false
          if let current = _storage._message {
            hadOneofValue = true
            if case .choiceMessage(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._message = .choiceMessage(v)
          }
        }()
        case 6: try {
          var v: Sinch_Conversationapi_Type_CardMessage?
          var hadOneofValue = false
          if let current = _storage._message {
            hadOneofValue = true
            if case .cardMessage(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._message = .cardMessage(v)
          }
        }()
        case 7: try {
          var v: Sinch_Conversationapi_Type_CarouselMessage?
          var hadOneofValue = false
          if let current = _storage._message {
            hadOneofValue = true
            if case .carouselMessage(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._message = .carouselMessage(v)
          }
        }()
        case 8: try {
          var v: Sinch_Conversationapi_Type_LocationMessage?
          var hadOneofValue = false
          if let current = _storage._message {
            hadOneofValue = true
            if case .locationMessage(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._message = .locationMessage(v)
          }
        }()
        case 9: try {
          var v: Sinch_Conversationapi_Type_ContactInfoMessage?
          var hadOneofValue = false
          if let current = _storage._message {
            hadOneofValue = true
            if case .contactInfoMessage(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._message = .contactInfoMessage(v)
          }
        }()
        case 10: try { try decoder.decodeSingularMessageField(value: &_storage._agent) }()
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every if/case branch local when no optimizations
      // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
      // https://github.com/apple/swift-protobuf/issues/1182
      if !_storage._explicitChannelMessage.isEmpty {
        try visitor.visitMapField(fieldType: SwiftProtobuf._ProtobufMap<SwiftProtobuf.ProtobufString,SwiftProtobuf.ProtobufString>.self, value: _storage._explicitChannelMessage, fieldNumber: 1)
      }
      switch _storage._message {
      case .textMessage?: try {
        guard case .textMessage(let v)? = _storage._message else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
      }()
      case .mediaMessage?: try {
        guard case .mediaMessage(let v)? = _storage._message else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
      }()
      case .templateMessage?: try {
        guard case .templateMessage(let v)? = _storage._message else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
      }()
      case .choiceMessage?: try {
        guard case .choiceMessage(let v)? = _storage._message else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
      }()
      case .cardMessage?: try {
        guard case .cardMessage(let v)? = _storage._message else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
      }()
      case .carouselMessage?: try {
        guard case .carouselMessage(let v)? = _storage._message else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 7)
      }()
      case .locationMessage?: try {
        guard case .locationMessage(let v)? = _storage._message else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 8)
      }()
      case .contactInfoMessage?: try {
        guard case .contactInfoMessage(let v)? = _storage._message else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 9)
      }()
      case nil: break
      }
      try { if let v = _storage._agent {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 10)
      } }()
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Sinch_Conversationapi_Type_AppMessage, rhs: Sinch_Conversationapi_Type_AppMessage) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._explicitChannelMessage != rhs_storage._explicitChannelMessage {return false}
        if _storage._message != rhs_storage._message {return false}
        if _storage._agent != rhs_storage._agent {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Sinch_Conversationapi_Type_ContactMessage: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ContactMessage"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "text_message"),
    2: .standard(proto: "media_message"),
    3: .standard(proto: "location_message"),
    4: .standard(proto: "choice_response_message"),
    6: .standard(proto: "media_card_message"),
    7: .standard(proto: "fallback_message"),
    5: .standard(proto: "reply_to"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try {
        var v: Sinch_Conversationapi_Type_TextMessage?
        var hadOneofValue = false
        if let current = self.message {
          hadOneofValue = true
          if case .textMessage(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.message = .textMessage(v)
        }
      }()
      case 2: try {
        var v: Sinch_Conversationapi_Type_MediaMessage?
        var hadOneofValue = false
        if let current = self.message {
          hadOneofValue = true
          if case .mediaMessage(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.message = .mediaMessage(v)
        }
      }()
      case 3: try {
        var v: Sinch_Conversationapi_Type_LocationMessage?
        var hadOneofValue = false
        if let current = self.message {
          hadOneofValue = true
          if case .locationMessage(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.message = .locationMessage(v)
        }
      }()
      case 4: try {
        var v: Sinch_Conversationapi_Type_ChoiceResponseMessage?
        var hadOneofValue = false
        if let current = self.message {
          hadOneofValue = true
          if case .choiceResponseMessage(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.message = .choiceResponseMessage(v)
        }
      }()
      case 5: try { try decoder.decodeSingularMessageField(value: &self._replyTo) }()
      case 6: try {
        var v: Sinch_Conversationapi_Type_MediaCardMessage?
        var hadOneofValue = false
        if let current = self.message {
          hadOneofValue = true
          if case .mediaCardMessage(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.message = .mediaCardMessage(v)
        }
      }()
      case 7: try {
        var v: Sinch_Conversationapi_Type_FallbackMessage?
        var hadOneofValue = false
        if let current = self.message {
          hadOneofValue = true
          if case .fallbackMessage(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.message = .fallbackMessage(v)
        }
      }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    switch self.message {
    case .textMessage?: try {
      guard case .textMessage(let v)? = self.message else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }()
    case .mediaMessage?: try {
      guard case .mediaMessage(let v)? = self.message else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }()
    case .locationMessage?: try {
      guard case .locationMessage(let v)? = self.message else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    }()
    case .choiceResponseMessage?: try {
      guard case .choiceResponseMessage(let v)? = self.message else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    }()
    default: break
    }
    try { if let v = self._replyTo {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
    } }()
    switch self.message {
    case .mediaCardMessage?: try {
      guard case .mediaCardMessage(let v)? = self.message else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
    }()
    case .fallbackMessage?: try {
      guard case .fallbackMessage(let v)? = self.message else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 7)
    }()
    default: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Sinch_Conversationapi_Type_ContactMessage, rhs: Sinch_Conversationapi_Type_ContactMessage) -> Bool {
    if lhs.message != rhs.message {return false}
    if lhs._replyTo != rhs._replyTo {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Sinch_Conversationapi_Type_TextMessage: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".TextMessage"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "text"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.text) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.text.isEmpty {
      try visitor.visitSingularStringField(value: self.text, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Sinch_Conversationapi_Type_TextMessage, rhs: Sinch_Conversationapi_Type_TextMessage) -> Bool {
    if lhs.text != rhs.text {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Sinch_Conversationapi_Type_MediaMessage: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".MediaMessage"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "url"),
    2: .standard(proto: "thumbnail_url"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.url) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.thumbnailURL) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.url.isEmpty {
      try visitor.visitSingularStringField(value: self.url, fieldNumber: 1)
    }
    if !self.thumbnailURL.isEmpty {
      try visitor.visitSingularStringField(value: self.thumbnailURL, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Sinch_Conversationapi_Type_MediaMessage, rhs: Sinch_Conversationapi_Type_MediaMessage) -> Bool {
    if lhs.url != rhs.url {return false}
    if lhs.thumbnailURL != rhs.thumbnailURL {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Sinch_Conversationapi_Type_MediaCardMessage: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".MediaCardMessage"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "url"),
    2: .same(proto: "caption"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.url) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.caption) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.url.isEmpty {
      try visitor.visitSingularStringField(value: self.url, fieldNumber: 1)
    }
    if !self.caption.isEmpty {
      try visitor.visitSingularStringField(value: self.caption, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Sinch_Conversationapi_Type_MediaCardMessage, rhs: Sinch_Conversationapi_Type_MediaCardMessage) -> Bool {
    if lhs.url != rhs.url {return false}
    if lhs.caption != rhs.caption {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Sinch_Conversationapi_Type_FallbackMessage: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".FallbackMessage"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "reason"),
    2: .standard(proto: "raw_message"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._reason) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.rawMessage) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._reason {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    if !self.rawMessage.isEmpty {
      try visitor.visitSingularStringField(value: self.rawMessage, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Sinch_Conversationapi_Type_FallbackMessage, rhs: Sinch_Conversationapi_Type_FallbackMessage) -> Bool {
    if lhs._reason != rhs._reason {return false}
    if lhs.rawMessage != rhs.rawMessage {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Sinch_Conversationapi_Type_TemplateMessage: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".TemplateMessage"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "channel_template"),
    2: .standard(proto: "omni_template"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeMapField(fieldType: SwiftProtobuf._ProtobufMessageMap<SwiftProtobuf.ProtobufString,Sinch_Conversationapi_Type_TemplateReference>.self, value: &self.channelTemplate) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._omniTemplate) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.channelTemplate.isEmpty {
      try visitor.visitMapField(fieldType: SwiftProtobuf._ProtobufMessageMap<SwiftProtobuf.ProtobufString,Sinch_Conversationapi_Type_TemplateReference>.self, value: self.channelTemplate, fieldNumber: 1)
    }
    try { if let v = self._omniTemplate {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Sinch_Conversationapi_Type_TemplateMessage, rhs: Sinch_Conversationapi_Type_TemplateMessage) -> Bool {
    if lhs.channelTemplate != rhs.channelTemplate {return false}
    if lhs._omniTemplate != rhs._omniTemplate {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Sinch_Conversationapi_Type_TemplateReference: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".TemplateReference"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "template_id"),
    2: .same(proto: "version"),
    3: .standard(proto: "language_code"),
    4: .same(proto: "parameters"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.templateID) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.version) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.languageCode) }()
      case 4: try { try decoder.decodeMapField(fieldType: SwiftProtobuf._ProtobufMap<SwiftProtobuf.ProtobufString,SwiftProtobuf.ProtobufString>.self, value: &self.parameters) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.templateID.isEmpty {
      try visitor.visitSingularStringField(value: self.templateID, fieldNumber: 1)
    }
    if !self.version.isEmpty {
      try visitor.visitSingularStringField(value: self.version, fieldNumber: 2)
    }
    if !self.languageCode.isEmpty {
      try visitor.visitSingularStringField(value: self.languageCode, fieldNumber: 3)
    }
    if !self.parameters.isEmpty {
      try visitor.visitMapField(fieldType: SwiftProtobuf._ProtobufMap<SwiftProtobuf.ProtobufString,SwiftProtobuf.ProtobufString>.self, value: self.parameters, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Sinch_Conversationapi_Type_TemplateReference, rhs: Sinch_Conversationapi_Type_TemplateReference) -> Bool {
    if lhs.templateID != rhs.templateID {return false}
    if lhs.version != rhs.version {return false}
    if lhs.languageCode != rhs.languageCode {return false}
    if lhs.parameters != rhs.parameters {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Sinch_Conversationapi_Type_LocationMessage: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".LocationMessage"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "title"),
    2: .same(proto: "coordinates"),
    3: .same(proto: "label"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.title) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._coordinates) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.label) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.title.isEmpty {
      try visitor.visitSingularStringField(value: self.title, fieldNumber: 1)
    }
    try { if let v = self._coordinates {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    if !self.label.isEmpty {
      try visitor.visitSingularStringField(value: self.label, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Sinch_Conversationapi_Type_LocationMessage, rhs: Sinch_Conversationapi_Type_LocationMessage) -> Bool {
    if lhs.title != rhs.title {return false}
    if lhs._coordinates != rhs._coordinates {return false}
    if lhs.label != rhs.label {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Sinch_Conversationapi_Type_Choice: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".Choice"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "text_message"),
    2: .standard(proto: "url_message"),
    3: .standard(proto: "call_message"),
    4: .standard(proto: "location_message"),
    5: .standard(proto: "postback_data"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try {
        var v: Sinch_Conversationapi_Type_TextMessage?
        var hadOneofValue = false
        if let current = self.choice {
          hadOneofValue = true
          if case .textMessage(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.choice = .textMessage(v)
        }
      }()
      case 2: try {
        var v: Sinch_Conversationapi_Type_UrlMessage?
        var hadOneofValue = false
        if let current = self.choice {
          hadOneofValue = true
          if case .urlMessage(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.choice = .urlMessage(v)
        }
      }()
      case 3: try {
        var v: Sinch_Conversationapi_Type_CallMessage?
        var hadOneofValue = false
        if let current = self.choice {
          hadOneofValue = true
          if case .callMessage(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.choice = .callMessage(v)
        }
      }()
      case 4: try {
        var v: Sinch_Conversationapi_Type_LocationMessage?
        var hadOneofValue = false
        if let current = self.choice {
          hadOneofValue = true
          if case .locationMessage(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.choice = .locationMessage(v)
        }
      }()
      case 5: try { try decoder.decodeSingularStringField(value: &self.postbackData) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    switch self.choice {
    case .textMessage?: try {
      guard case .textMessage(let v)? = self.choice else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }()
    case .urlMessage?: try {
      guard case .urlMessage(let v)? = self.choice else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }()
    case .callMessage?: try {
      guard case .callMessage(let v)? = self.choice else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    }()
    case .locationMessage?: try {
      guard case .locationMessage(let v)? = self.choice else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    }()
    case nil: break
    }
    if !self.postbackData.isEmpty {
      try visitor.visitSingularStringField(value: self.postbackData, fieldNumber: 5)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Sinch_Conversationapi_Type_Choice, rhs: Sinch_Conversationapi_Type_Choice) -> Bool {
    if lhs.choice != rhs.choice {return false}
    if lhs.postbackData != rhs.postbackData {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Sinch_Conversationapi_Type_CallMessage: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".CallMessage"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "title"),
    2: .standard(proto: "phone_number"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.title) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.phoneNumber) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.title.isEmpty {
      try visitor.visitSingularStringField(value: self.title, fieldNumber: 1)
    }
    if !self.phoneNumber.isEmpty {
      try visitor.visitSingularStringField(value: self.phoneNumber, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Sinch_Conversationapi_Type_CallMessage, rhs: Sinch_Conversationapi_Type_CallMessage) -> Bool {
    if lhs.title != rhs.title {return false}
    if lhs.phoneNumber != rhs.phoneNumber {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Sinch_Conversationapi_Type_ChoiceMessage: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ChoiceMessage"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "text_message"),
    2: .same(proto: "choices"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._textMessage) }()
      case 2: try { try decoder.decodeRepeatedMessageField(value: &self.choices) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._textMessage {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    if !self.choices.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.choices, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Sinch_Conversationapi_Type_ChoiceMessage, rhs: Sinch_Conversationapi_Type_ChoiceMessage) -> Bool {
    if lhs._textMessage != rhs._textMessage {return false}
    if lhs.choices != rhs.choices {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Sinch_Conversationapi_Type_CardMessage: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".CardMessage"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "title"),
    2: .same(proto: "description"),
    3: .standard(proto: "media_message"),
    4: .same(proto: "choices"),
    5: .same(proto: "height"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.title) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.description_p) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._mediaMessage) }()
      case 4: try { try decoder.decodeRepeatedMessageField(value: &self.choices) }()
      case 5: try { try decoder.decodeSingularEnumField(value: &self.height) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.title.isEmpty {
      try visitor.visitSingularStringField(value: self.title, fieldNumber: 1)
    }
    if !self.description_p.isEmpty {
      try visitor.visitSingularStringField(value: self.description_p, fieldNumber: 2)
    }
    try { if let v = self._mediaMessage {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    if !self.choices.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.choices, fieldNumber: 4)
    }
    if self.height != .unspecifiedHeight {
      try visitor.visitSingularEnumField(value: self.height, fieldNumber: 5)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Sinch_Conversationapi_Type_CardMessage, rhs: Sinch_Conversationapi_Type_CardMessage) -> Bool {
    if lhs.title != rhs.title {return false}
    if lhs.description_p != rhs.description_p {return false}
    if lhs._mediaMessage != rhs._mediaMessage {return false}
    if lhs.choices != rhs.choices {return false}
    if lhs.height != rhs.height {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Sinch_Conversationapi_Type_CarouselMessage: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".CarouselMessage"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "cards"),
    2: .same(proto: "choices"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.cards) }()
      case 2: try { try decoder.decodeRepeatedMessageField(value: &self.choices) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.cards.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.cards, fieldNumber: 1)
    }
    if !self.choices.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.choices, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Sinch_Conversationapi_Type_CarouselMessage, rhs: Sinch_Conversationapi_Type_CarouselMessage) -> Bool {
    if lhs.cards != rhs.cards {return false}
    if lhs.choices != rhs.choices {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Sinch_Conversationapi_Type_ChoiceResponseMessage: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ChoiceResponseMessage"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "message_id"),
    2: .standard(proto: "postback_data"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.messageID) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.postbackData) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.messageID.isEmpty {
      try visitor.visitSingularStringField(value: self.messageID, fieldNumber: 1)
    }
    if !self.postbackData.isEmpty {
      try visitor.visitSingularStringField(value: self.postbackData, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Sinch_Conversationapi_Type_ChoiceResponseMessage, rhs: Sinch_Conversationapi_Type_ChoiceResponseMessage) -> Bool {
    if lhs.messageID != rhs.messageID {return false}
    if lhs.postbackData != rhs.postbackData {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Sinch_Conversationapi_Type_UrlMessage: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".UrlMessage"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "title"),
    2: .same(proto: "url"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.title) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.url) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.title.isEmpty {
      try visitor.visitSingularStringField(value: self.title, fieldNumber: 1)
    }
    if !self.url.isEmpty {
      try visitor.visitSingularStringField(value: self.url, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Sinch_Conversationapi_Type_UrlMessage, rhs: Sinch_Conversationapi_Type_UrlMessage) -> Bool {
    if lhs.title != rhs.title {return false}
    if lhs.url != rhs.url {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Sinch_Conversationapi_Type_ReplyTo: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ReplyTo"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "message_id"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.messageID) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.messageID.isEmpty {
      try visitor.visitSingularStringField(value: self.messageID, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Sinch_Conversationapi_Type_ReplyTo, rhs: Sinch_Conversationapi_Type_ReplyTo) -> Bool {
    if lhs.messageID != rhs.messageID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Sinch_Conversationapi_Type_ContactInfoMessage: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ContactInfoMessage"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "name"),
    2: .standard(proto: "phone_numbers"),
    3: .same(proto: "addresses"),
    4: .standard(proto: "email_addresses"),
    5: .same(proto: "organization"),
    6: .same(proto: "urls"),
    7: .same(proto: "birthday"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._name) }()
      case 2: try { try decoder.decodeRepeatedMessageField(value: &self.phoneNumbers) }()
      case 3: try { try decoder.decodeRepeatedMessageField(value: &self.addresses) }()
      case 4: try { try decoder.decodeRepeatedMessageField(value: &self.emailAddresses) }()
      case 5: try { try decoder.decodeSingularMessageField(value: &self._organization) }()
      case 6: try { try decoder.decodeRepeatedMessageField(value: &self.urls) }()
      case 7: try { try decoder.decodeSingularStringField(value: &self.birthday) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._name {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    if !self.phoneNumbers.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.phoneNumbers, fieldNumber: 2)
    }
    if !self.addresses.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.addresses, fieldNumber: 3)
    }
    if !self.emailAddresses.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.emailAddresses, fieldNumber: 4)
    }
    try { if let v = self._organization {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
    } }()
    if !self.urls.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.urls, fieldNumber: 6)
    }
    if !self.birthday.isEmpty {
      try visitor.visitSingularStringField(value: self.birthday, fieldNumber: 7)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Sinch_Conversationapi_Type_ContactInfoMessage, rhs: Sinch_Conversationapi_Type_ContactInfoMessage) -> Bool {
    if lhs._name != rhs._name {return false}
    if lhs.phoneNumbers != rhs.phoneNumbers {return false}
    if lhs.addresses != rhs.addresses {return false}
    if lhs.emailAddresses != rhs.emailAddresses {return false}
    if lhs._organization != rhs._organization {return false}
    if lhs.urls != rhs.urls {return false}
    if lhs.birthday != rhs.birthday {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Sinch_Conversationapi_Type_AddressInfo: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".AddressInfo"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "city"),
    2: .same(proto: "country"),
    3: .same(proto: "state"),
    4: .same(proto: "street"),
    5: .same(proto: "zip"),
    6: .same(proto: "type"),
    7: .standard(proto: "country_code"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.city) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.country) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.state) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.street) }()
      case 5: try { try decoder.decodeSingularStringField(value: &self.zip) }()
      case 6: try { try decoder.decodeSingularStringField(value: &self.type) }()
      case 7: try { try decoder.decodeSingularStringField(value: &self.countryCode) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.city.isEmpty {
      try visitor.visitSingularStringField(value: self.city, fieldNumber: 1)
    }
    if !self.country.isEmpty {
      try visitor.visitSingularStringField(value: self.country, fieldNumber: 2)
    }
    if !self.state.isEmpty {
      try visitor.visitSingularStringField(value: self.state, fieldNumber: 3)
    }
    if !self.street.isEmpty {
      try visitor.visitSingularStringField(value: self.street, fieldNumber: 4)
    }
    if !self.zip.isEmpty {
      try visitor.visitSingularStringField(value: self.zip, fieldNumber: 5)
    }
    if !self.type.isEmpty {
      try visitor.visitSingularStringField(value: self.type, fieldNumber: 6)
    }
    if !self.countryCode.isEmpty {
      try visitor.visitSingularStringField(value: self.countryCode, fieldNumber: 7)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Sinch_Conversationapi_Type_AddressInfo, rhs: Sinch_Conversationapi_Type_AddressInfo) -> Bool {
    if lhs.city != rhs.city {return false}
    if lhs.country != rhs.country {return false}
    if lhs.state != rhs.state {return false}
    if lhs.street != rhs.street {return false}
    if lhs.zip != rhs.zip {return false}
    if lhs.type != rhs.type {return false}
    if lhs.countryCode != rhs.countryCode {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Sinch_Conversationapi_Type_EmailInfo: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".EmailInfo"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "email_address"),
    2: .same(proto: "type"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.emailAddress) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.type) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.emailAddress.isEmpty {
      try visitor.visitSingularStringField(value: self.emailAddress, fieldNumber: 1)
    }
    if !self.type.isEmpty {
      try visitor.visitSingularStringField(value: self.type, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Sinch_Conversationapi_Type_EmailInfo, rhs: Sinch_Conversationapi_Type_EmailInfo) -> Bool {
    if lhs.emailAddress != rhs.emailAddress {return false}
    if lhs.type != rhs.type {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Sinch_Conversationapi_Type_NameInfo: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".NameInfo"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "full_name"),
    2: .standard(proto: "first_name"),
    3: .standard(proto: "last_name"),
    4: .standard(proto: "middle_name"),
    5: .same(proto: "prefix"),
    6: .same(proto: "suffix"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.fullName) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.firstName) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.lastName) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.middleName) }()
      case 5: try { try decoder.decodeSingularStringField(value: &self.prefix) }()
      case 6: try { try decoder.decodeSingularStringField(value: &self.suffix) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.fullName.isEmpty {
      try visitor.visitSingularStringField(value: self.fullName, fieldNumber: 1)
    }
    if !self.firstName.isEmpty {
      try visitor.visitSingularStringField(value: self.firstName, fieldNumber: 2)
    }
    if !self.lastName.isEmpty {
      try visitor.visitSingularStringField(value: self.lastName, fieldNumber: 3)
    }
    if !self.middleName.isEmpty {
      try visitor.visitSingularStringField(value: self.middleName, fieldNumber: 4)
    }
    if !self.prefix.isEmpty {
      try visitor.visitSingularStringField(value: self.prefix, fieldNumber: 5)
    }
    if !self.suffix.isEmpty {
      try visitor.visitSingularStringField(value: self.suffix, fieldNumber: 6)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Sinch_Conversationapi_Type_NameInfo, rhs: Sinch_Conversationapi_Type_NameInfo) -> Bool {
    if lhs.fullName != rhs.fullName {return false}
    if lhs.firstName != rhs.firstName {return false}
    if lhs.lastName != rhs.lastName {return false}
    if lhs.middleName != rhs.middleName {return false}
    if lhs.prefix != rhs.prefix {return false}
    if lhs.suffix != rhs.suffix {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Sinch_Conversationapi_Type_OrganizationInfo: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".OrganizationInfo"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "company"),
    2: .same(proto: "department"),
    3: .same(proto: "title"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.company) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.department) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.title) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.company.isEmpty {
      try visitor.visitSingularStringField(value: self.company, fieldNumber: 1)
    }
    if !self.department.isEmpty {
      try visitor.visitSingularStringField(value: self.department, fieldNumber: 2)
    }
    if !self.title.isEmpty {
      try visitor.visitSingularStringField(value: self.title, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Sinch_Conversationapi_Type_OrganizationInfo, rhs: Sinch_Conversationapi_Type_OrganizationInfo) -> Bool {
    if lhs.company != rhs.company {return false}
    if lhs.department != rhs.department {return false}
    if lhs.title != rhs.title {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Sinch_Conversationapi_Type_PhoneNumberInfo: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".PhoneNumberInfo"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "phone_number"),
    2: .same(proto: "type"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.phoneNumber) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.type) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.phoneNumber.isEmpty {
      try visitor.visitSingularStringField(value: self.phoneNumber, fieldNumber: 1)
    }
    if !self.type.isEmpty {
      try visitor.visitSingularStringField(value: self.type, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Sinch_Conversationapi_Type_PhoneNumberInfo, rhs: Sinch_Conversationapi_Type_PhoneNumberInfo) -> Bool {
    if lhs.phoneNumber != rhs.phoneNumber {return false}
    if lhs.type != rhs.type {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Sinch_Conversationapi_Type_UrlInfo: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".UrlInfo"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "url"),
    2: .same(proto: "type"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.url) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.type) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.url.isEmpty {
      try visitor.visitSingularStringField(value: self.url, fieldNumber: 1)
    }
    if !self.type.isEmpty {
      try visitor.visitSingularStringField(value: self.type, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Sinch_Conversationapi_Type_UrlInfo, rhs: Sinch_Conversationapi_Type_UrlInfo) -> Bool {
    if lhs.url != rhs.url {return false}
    if lhs.type != rhs.type {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}
