// DO NOT EDIT.
// swift-format-ignore-file
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: sinch/conversationapi/type/authentication.proto
//
// For information on using the generated types, please see the documentation:
//   https://github.com/apple/swift-protobuf/

import Foundation
import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that you are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

/// Status of the channel credentials integration.
enum Sinch_Conversationapi_Type_ChannelIntegrationStatus: SwiftProtobuf.Enum {
  typealias RawValue = Int

  /// Pending - initial status when the channel has been activated in the front-end.
  case pending // = 0

  /// Active - credentials have been successfully validated and exchanged for a long-lived token.
  /// This status is used by default for channels in which the credential can't be validated.
  case active // = 1

  /// Failed - failed to validate credentials and acquire a long-lived token.
  case failing // = 2
  case UNRECOGNIZED(Int)

  init() {
    self = .pending
  }

  init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .pending
    case 1: self = .active
    case 2: self = .failing
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  var rawValue: Int {
    switch self {
    case .pending: return 0
    case .active: return 1
    case .failing: return 2
    case .UNRECOGNIZED(let i): return i
    }
  }

}

#if swift(>=4.2)

extension Sinch_Conversationapi_Type_ChannelIntegrationStatus: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  static let allCases: [Sinch_Conversationapi_Type_ChannelIntegrationStatus] = [
    .pending,
    .active,
    .failing,
  ]
}

#endif  // swift(>=4.2)

/// Channel Credential
///
/// Enables access to the underlying messaging channel.
struct Sinch_Conversationapi_Type_ConversationChannelCredential {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Required. The identifier of the messaging channel.
  var channel: Sinch_Conversationapi_Type_ConversationChannel = .channelUnspecified

  /// Required. The channel credential enabling access to the underlying messaging channel.
  var credential: Sinch_Conversationapi_Type_ConversationChannelCredential.OneOf_Credential? = nil

  var staticBearer: Sinch_Conversationapi_Type_StaticBearerCredential {
    get {
      if case .staticBearer(let v)? = credential {return v}
      return Sinch_Conversationapi_Type_StaticBearerCredential()
    }
    set {credential = .staticBearer(newValue)}
  }

  var staticToken: Sinch_Conversationapi_Type_StaticTokenCredential {
    get {
      if case .staticToken(let v)? = credential {return v}
      return Sinch_Conversationapi_Type_StaticTokenCredential()
    }
    set {credential = .staticToken(newValue)}
  }

  /// MMS specific channel credentials.
  var mmsCredentials: Sinch_Conversationapi_Type_MMSCredentials {
    get {
      if case .mmsCredentials(let v)? = credential {return v}
      return Sinch_Conversationapi_Type_MMSCredentials()
    }
    set {credential = .mmsCredentials(newValue)}
  }

  /// Telegram specific channel credentials.
  var telegramCredentials: Sinch_Conversationapi_Type_TelegramCredentials {
    get {
      if case .telegramCredentials(let v)? = credential {return v}
      return Sinch_Conversationapi_Type_TelegramCredentials()
    }
    set {credential = .telegramCredentials(newValue)}
  }

  /// Instagram specific channel credentials.
  var instagramCredentials: Sinch_Conversationapi_Type_InstagramCredentials {
    get {
      if case .instagramCredentials(let v)? = credential {return v}
      return Sinch_Conversationapi_Type_InstagramCredentials()
    }
    set {credential = .instagramCredentials(newValue)}
  }

  /// KakaoTalk specific channel credentials.
  var kakaotalkCredentials: Sinch_Conversationapi_Type_KakaoTalkCredentials {
    get {
      if case .kakaotalkCredentials(let v)? = credential {return v}
      return Sinch_Conversationapi_Type_KakaoTalkCredentials()
    }
    set {credential = .kakaotalkCredentials(newValue)}
  }

  /// Apple Business Chat specific channel credentials.
  var applebcCredentials: Sinch_Conversationapi_Type_AppleBcCredentials {
    get {
      if case .applebcCredentials(let v)? = credential {return v}
      return Sinch_Conversationapi_Type_AppleBcCredentials()
    }
    set {credential = .applebcCredentials(newValue)}
  }

  /// WeChat specific channel credentials.
  var wechatCredentials: Sinch_Conversationapi_Type_WeChatCredentials {
    get {
      if case .wechatCredentials(let v)? = credential {return v}
      return Sinch_Conversationapi_Type_WeChatCredentials()
    }
    set {credential = .wechatCredentials(newValue)}
  }

  /// Line specific channel credentials.
  var lineCredentials: Sinch_Conversationapi_Type_LineCredentials {
    get {
      if case .lineCredentials(let v)? = credential {return v}
      return Sinch_Conversationapi_Type_LineCredentials()
    }
    set {credential = .lineCredentials(newValue)}
  }

  /// KakaoTalkChat (2-way communication) specific channel credentials.
  var kakaotalkchatCredentials: Sinch_Conversationapi_Type_KakaoTalkChatCredentials {
    get {
      if case .kakaotalkchatCredentials(let v)? = credential {return v}
      return Sinch_Conversationapi_Type_KakaoTalkChatCredentials()
    }
    set {credential = .kakaotalkchatCredentials(newValue)}
  }

  /// Optional. The secret used to verify the channel callbacks
  /// for channels which support callback verification.
  /// The callback verification is not needed for Sinch-managed
  /// channels because the callbacks are not leaving
  /// Sinch internal networks.
  /// Max length is 256 characters.
  /// Note: leaving channel_callback_secret empty for channels with
  /// callback verification will disable the verification. 
  var callbackSecret: String = String()

  /// Output only. The state of the channel credentials integration.
  /// When a channel is activated, the user is prompted for credentials that must
  /// be validated and in some cases exchanged by a long-lived token (Instagram).
  var state: Sinch_Conversationapi_Type_ChannelIntegrationState {
    get {return _state ?? Sinch_Conversationapi_Type_ChannelIntegrationState()}
    set {_state = newValue}
  }
  /// Returns true if `state` has been explicitly set.
  var hasState: Bool {return self._state != nil}
  /// Clears the value of `state`. Subsequent reads from it will return its default value.
  mutating func clearState() {self._state = nil}

  /// Output only. Additional identifier set by the channel that represents an specific
  /// id used by the channel. 
  var channelKnownID: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  /// Required. The channel credential enabling access to the underlying messaging channel.
  enum OneOf_Credential: Equatable {
    case staticBearer(Sinch_Conversationapi_Type_StaticBearerCredential)
    case staticToken(Sinch_Conversationapi_Type_StaticTokenCredential)
    /// MMS specific channel credentials.
    case mmsCredentials(Sinch_Conversationapi_Type_MMSCredentials)
    /// Telegram specific channel credentials.
    case telegramCredentials(Sinch_Conversationapi_Type_TelegramCredentials)
    /// Instagram specific channel credentials.
    case instagramCredentials(Sinch_Conversationapi_Type_InstagramCredentials)
    /// KakaoTalk specific channel credentials.
    case kakaotalkCredentials(Sinch_Conversationapi_Type_KakaoTalkCredentials)
    /// Apple Business Chat specific channel credentials.
    case applebcCredentials(Sinch_Conversationapi_Type_AppleBcCredentials)
    /// WeChat specific channel credentials.
    case wechatCredentials(Sinch_Conversationapi_Type_WeChatCredentials)
    /// Line specific channel credentials.
    case lineCredentials(Sinch_Conversationapi_Type_LineCredentials)
    /// KakaoTalkChat (2-way communication) specific channel credentials.
    case kakaotalkchatCredentials(Sinch_Conversationapi_Type_KakaoTalkChatCredentials)

  #if !swift(>=4.1)
    static func ==(lhs: Sinch_Conversationapi_Type_ConversationChannelCredential.OneOf_Credential, rhs: Sinch_Conversationapi_Type_ConversationChannelCredential.OneOf_Credential) -> Bool {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch (lhs, rhs) {
      case (.staticBearer, .staticBearer): return {
        guard case .staticBearer(let l) = lhs, case .staticBearer(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.staticToken, .staticToken): return {
        guard case .staticToken(let l) = lhs, case .staticToken(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.mmsCredentials, .mmsCredentials): return {
        guard case .mmsCredentials(let l) = lhs, case .mmsCredentials(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.telegramCredentials, .telegramCredentials): return {
        guard case .telegramCredentials(let l) = lhs, case .telegramCredentials(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.instagramCredentials, .instagramCredentials): return {
        guard case .instagramCredentials(let l) = lhs, case .instagramCredentials(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.kakaotalkCredentials, .kakaotalkCredentials): return {
        guard case .kakaotalkCredentials(let l) = lhs, case .kakaotalkCredentials(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.applebcCredentials, .applebcCredentials): return {
        guard case .applebcCredentials(let l) = lhs, case .applebcCredentials(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.wechatCredentials, .wechatCredentials): return {
        guard case .wechatCredentials(let l) = lhs, case .wechatCredentials(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.lineCredentials, .lineCredentials): return {
        guard case .lineCredentials(let l) = lhs, case .lineCredentials(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.kakaotalkchatCredentials, .kakaotalkchatCredentials): return {
        guard case .kakaotalkchatCredentials(let l) = lhs, case .kakaotalkchatCredentials(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      default: return false
      }
    }
  #endif
  }

  init() {}

  fileprivate var _state: Sinch_Conversationapi_Type_ChannelIntegrationState? = nil
}

/// Bearer Channel Credential
///
/// It consists of claimed identity and a static token.
struct Sinch_Conversationapi_Type_StaticBearerCredential {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Required. Claimed identity.
  var claimedIdentity: String = String()

  /// Required. Static bearer token.
  var token: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// Static Token Credential
struct Sinch_Conversationapi_Type_StaticTokenCredential {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Required. The static token.
  var token: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// Basic Auth Credential
///
/// It consists of a username and a password.
struct Sinch_Conversationapi_Type_BasicAuthCredential {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Required. Basic auth username.
  var username: String = String()

  /// Required. Basic auth password.
  var password: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// MMS channel credential
struct Sinch_Conversationapi_Type_MMSCredentials {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Required. The static token.
  var basicAuth: Sinch_Conversationapi_Type_BasicAuthCredential {
    get {return _basicAuth ?? Sinch_Conversationapi_Type_BasicAuthCredential()}
    set {_basicAuth = newValue}
  }
  /// Returns true if `basicAuth` has been explicitly set.
  var hasBasicAuth: Bool {return self._basicAuth != nil}
  /// Clears the value of `basicAuth`. Subsequent reads from it will return its default value.
  mutating func clearBasicAuth() {self._basicAuth = nil}

  /// Required. MMS Account ID.
  var accountID: String = String()

  /// Required. MMS API Key.
  var apiKey: String = String()

  /// Optional. Used when MMS_SENDER property not set
  var defaultSender: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _basicAuth: Sinch_Conversationapi_Type_BasicAuthCredential? = nil
}

/// Telegram channel credential
struct Sinch_Conversationapi_Type_TelegramCredentials {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Required. The static token.
  var token: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// Instagram channel credential
struct Sinch_Conversationapi_Type_InstagramCredentials {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Required. The static token.
  var token: String = String()

  /// Optional. Required if using the Sinch Facebook App.
  var businessAccountID: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// KakaoTalk channel credential
struct Sinch_Conversationapi_Type_KakaoTalkCredentials {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Required. Kakaotalk Plus friend ID.
  var kakaotalkPlusFriendID: String = String()

  /// Required. The KakaoTalk Sender Key.
  var kakaotalkSenderKey: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// Apple Business Chat channel credential
struct Sinch_Conversationapi_Type_AppleBcCredentials {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Required. The ID that identifies a Business Chat Account (BCA).
  var businessChatAccountID: String = String()

  /// Optional. Merchant ID, required if our client wants to use Apple Pay.
  var merchantID: String = String()

  /// Optional. Certificate reference, required if our client wants to use Apple Pay.
  var applePayCertificateReference: String = String()

  /// Optional. Certificate password, required if our client wants to use Apple Pay.
  var applePayCertificatePassword: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// State of the channel credentials integration.
/// If there was an error, a description may be provided.
struct Sinch_Conversationapi_Type_ChannelIntegrationState {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Required. The integration status.
  var status: Sinch_Conversationapi_Type_ChannelIntegrationStatus = .pending

  /// Optional. Description in case the integration fails.
  var description_p: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// WeChat channel credential
struct Sinch_Conversationapi_Type_WeChatCredentials {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Required. App ID
  var appID: String = String()

  /// Required. App Secret.
  var appSecret: String = String()

  /// Required. Token, used to validate signature header in MO.
  var token: String = String()

  /// Required. AES Key, used to decode encrypted MO content
  var aesKey: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// Line channel credential
struct Sinch_Conversationapi_Type_LineCredentials {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Required. The static access token.
  var token: String = String()

  /// Required. Channel Secret.
  var secret: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// KakaoTalkChat channel credential
struct Sinch_Conversationapi_Type_KakaoTalkChatCredentials {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Required. Kakaotalk Plus friend ID.
  var kakaotalkPlusFriendID: String = String()

  /// Optional. InfoBank API KEY.
  var apiKey: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

#if swift(>=5.5) && canImport(_Concurrency)
extension Sinch_Conversationapi_Type_ChannelIntegrationStatus: @unchecked Sendable {}
extension Sinch_Conversationapi_Type_ConversationChannelCredential: @unchecked Sendable {}
extension Sinch_Conversationapi_Type_ConversationChannelCredential.OneOf_Credential: @unchecked Sendable {}
extension Sinch_Conversationapi_Type_StaticBearerCredential: @unchecked Sendable {}
extension Sinch_Conversationapi_Type_StaticTokenCredential: @unchecked Sendable {}
extension Sinch_Conversationapi_Type_BasicAuthCredential: @unchecked Sendable {}
extension Sinch_Conversationapi_Type_MMSCredentials: @unchecked Sendable {}
extension Sinch_Conversationapi_Type_TelegramCredentials: @unchecked Sendable {}
extension Sinch_Conversationapi_Type_InstagramCredentials: @unchecked Sendable {}
extension Sinch_Conversationapi_Type_KakaoTalkCredentials: @unchecked Sendable {}
extension Sinch_Conversationapi_Type_AppleBcCredentials: @unchecked Sendable {}
extension Sinch_Conversationapi_Type_ChannelIntegrationState: @unchecked Sendable {}
extension Sinch_Conversationapi_Type_WeChatCredentials: @unchecked Sendable {}
extension Sinch_Conversationapi_Type_LineCredentials: @unchecked Sendable {}
extension Sinch_Conversationapi_Type_KakaoTalkChatCredentials: @unchecked Sendable {}
#endif  // swift(>=5.5) && canImport(_Concurrency)

// MARK: - Code below here is support for the SwiftProtobuf runtime.

fileprivate let _protobuf_package = "sinch.conversationapi.type"

extension Sinch_Conversationapi_Type_ChannelIntegrationStatus: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "PENDING"),
    1: .same(proto: "ACTIVE"),
    2: .same(proto: "FAILING"),
  ]
}

extension Sinch_Conversationapi_Type_ConversationChannelCredential: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ConversationChannelCredential"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "channel"),
    3: .standard(proto: "static_bearer"),
    4: .standard(proto: "static_token"),
    6: .standard(proto: "mms_credentials"),
    7: .standard(proto: "telegram_credentials"),
    8: .standard(proto: "instagram_credentials"),
    9: .standard(proto: "kakaotalk_credentials"),
    11: .standard(proto: "applebc_credentials"),
    12: .standard(proto: "wechat_credentials"),
    13: .standard(proto: "line_credentials"),
    15: .standard(proto: "kakaotalkchat_credentials"),
    5: .standard(proto: "callback_secret"),
    10: .same(proto: "state"),
    14: .standard(proto: "channel_known_id"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.channel) }()
      case 3: try {
        var v: Sinch_Conversationapi_Type_StaticBearerCredential?
        var hadOneofValue = false
        if let current = self.credential {
          hadOneofValue = true
          if case .staticBearer(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.credential = .staticBearer(v)
        }
      }()
      case 4: try {
        var v: Sinch_Conversationapi_Type_StaticTokenCredential?
        var hadOneofValue = false
        if let current = self.credential {
          hadOneofValue = true
          if case .staticToken(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.credential = .staticToken(v)
        }
      }()
      case 5: try { try decoder.decodeSingularStringField(value: &self.callbackSecret) }()
      case 6: try {
        var v: Sinch_Conversationapi_Type_MMSCredentials?
        var hadOneofValue = false
        if let current = self.credential {
          hadOneofValue = true
          if case .mmsCredentials(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.credential = .mmsCredentials(v)
        }
      }()
      case 7: try {
        var v: Sinch_Conversationapi_Type_TelegramCredentials?
        var hadOneofValue = false
        if let current = self.credential {
          hadOneofValue = true
          if case .telegramCredentials(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.credential = .telegramCredentials(v)
        }
      }()
      case 8: try {
        var v: Sinch_Conversationapi_Type_InstagramCredentials?
        var hadOneofValue = false
        if let current = self.credential {
          hadOneofValue = true
          if case .instagramCredentials(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.credential = .instagramCredentials(v)
        }
      }()
      case 9: try {
        var v: Sinch_Conversationapi_Type_KakaoTalkCredentials?
        var hadOneofValue = false
        if let current = self.credential {
          hadOneofValue = true
          if case .kakaotalkCredentials(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.credential = .kakaotalkCredentials(v)
        }
      }()
      case 10: try { try decoder.decodeSingularMessageField(value: &self._state) }()
      case 11: try {
        var v: Sinch_Conversationapi_Type_AppleBcCredentials?
        var hadOneofValue = false
        if let current = self.credential {
          hadOneofValue = true
          if case .applebcCredentials(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.credential = .applebcCredentials(v)
        }
      }()
      case 12: try {
        var v: Sinch_Conversationapi_Type_WeChatCredentials?
        var hadOneofValue = false
        if let current = self.credential {
          hadOneofValue = true
          if case .wechatCredentials(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.credential = .wechatCredentials(v)
        }
      }()
      case 13: try {
        var v: Sinch_Conversationapi_Type_LineCredentials?
        var hadOneofValue = false
        if let current = self.credential {
          hadOneofValue = true
          if case .lineCredentials(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.credential = .lineCredentials(v)
        }
      }()
      case 14: try { try decoder.decodeSingularStringField(value: &self.channelKnownID) }()
      case 15: try {
        var v: Sinch_Conversationapi_Type_KakaoTalkChatCredentials?
        var hadOneofValue = false
        if let current = self.credential {
          hadOneofValue = true
          if case .kakaotalkchatCredentials(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.credential = .kakaotalkchatCredentials(v)
        }
      }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if self.channel != .channelUnspecified {
      try visitor.visitSingularEnumField(value: self.channel, fieldNumber: 1)
    }
    switch self.credential {
    case .staticBearer?: try {
      guard case .staticBearer(let v)? = self.credential else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    }()
    case .staticToken?: try {
      guard case .staticToken(let v)? = self.credential else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    }()
    default: break
    }
    if !self.callbackSecret.isEmpty {
      try visitor.visitSingularStringField(value: self.callbackSecret, fieldNumber: 5)
    }
    switch self.credential {
    case .mmsCredentials?: try {
      guard case .mmsCredentials(let v)? = self.credential else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
    }()
    case .telegramCredentials?: try {
      guard case .telegramCredentials(let v)? = self.credential else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 7)
    }()
    case .instagramCredentials?: try {
      guard case .instagramCredentials(let v)? = self.credential else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 8)
    }()
    case .kakaotalkCredentials?: try {
      guard case .kakaotalkCredentials(let v)? = self.credential else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 9)
    }()
    default: break
    }
    try { if let v = self._state {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 10)
    } }()
    switch self.credential {
    case .applebcCredentials?: try {
      guard case .applebcCredentials(let v)? = self.credential else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 11)
    }()
    case .wechatCredentials?: try {
      guard case .wechatCredentials(let v)? = self.credential else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 12)
    }()
    case .lineCredentials?: try {
      guard case .lineCredentials(let v)? = self.credential else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 13)
    }()
    default: break
    }
    if !self.channelKnownID.isEmpty {
      try visitor.visitSingularStringField(value: self.channelKnownID, fieldNumber: 14)
    }
    try { if case .kakaotalkchatCredentials(let v)? = self.credential {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 15)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Sinch_Conversationapi_Type_ConversationChannelCredential, rhs: Sinch_Conversationapi_Type_ConversationChannelCredential) -> Bool {
    if lhs.channel != rhs.channel {return false}
    if lhs.credential != rhs.credential {return false}
    if lhs.callbackSecret != rhs.callbackSecret {return false}
    if lhs._state != rhs._state {return false}
    if lhs.channelKnownID != rhs.channelKnownID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Sinch_Conversationapi_Type_StaticBearerCredential: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".StaticBearerCredential"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "claimed_identity"),
    2: .same(proto: "token"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.claimedIdentity) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.token) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.claimedIdentity.isEmpty {
      try visitor.visitSingularStringField(value: self.claimedIdentity, fieldNumber: 1)
    }
    if !self.token.isEmpty {
      try visitor.visitSingularStringField(value: self.token, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Sinch_Conversationapi_Type_StaticBearerCredential, rhs: Sinch_Conversationapi_Type_StaticBearerCredential) -> Bool {
    if lhs.claimedIdentity != rhs.claimedIdentity {return false}
    if lhs.token != rhs.token {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Sinch_Conversationapi_Type_StaticTokenCredential: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".StaticTokenCredential"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "token"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.token) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.token.isEmpty {
      try visitor.visitSingularStringField(value: self.token, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Sinch_Conversationapi_Type_StaticTokenCredential, rhs: Sinch_Conversationapi_Type_StaticTokenCredential) -> Bool {
    if lhs.token != rhs.token {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Sinch_Conversationapi_Type_BasicAuthCredential: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".BasicAuthCredential"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "username"),
    2: .same(proto: "password"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.username) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.password) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.username.isEmpty {
      try visitor.visitSingularStringField(value: self.username, fieldNumber: 1)
    }
    if !self.password.isEmpty {
      try visitor.visitSingularStringField(value: self.password, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Sinch_Conversationapi_Type_BasicAuthCredential, rhs: Sinch_Conversationapi_Type_BasicAuthCredential) -> Bool {
    if lhs.username != rhs.username {return false}
    if lhs.password != rhs.password {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Sinch_Conversationapi_Type_MMSCredentials: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".MMSCredentials"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "basic_auth"),
    2: .standard(proto: "account_id"),
    3: .standard(proto: "api_key"),
    4: .standard(proto: "default_sender"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._basicAuth) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.accountID) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.apiKey) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.defaultSender) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._basicAuth {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    if !self.accountID.isEmpty {
      try visitor.visitSingularStringField(value: self.accountID, fieldNumber: 2)
    }
    if !self.apiKey.isEmpty {
      try visitor.visitSingularStringField(value: self.apiKey, fieldNumber: 3)
    }
    if !self.defaultSender.isEmpty {
      try visitor.visitSingularStringField(value: self.defaultSender, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Sinch_Conversationapi_Type_MMSCredentials, rhs: Sinch_Conversationapi_Type_MMSCredentials) -> Bool {
    if lhs._basicAuth != rhs._basicAuth {return false}
    if lhs.accountID != rhs.accountID {return false}
    if lhs.apiKey != rhs.apiKey {return false}
    if lhs.defaultSender != rhs.defaultSender {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Sinch_Conversationapi_Type_TelegramCredentials: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".TelegramCredentials"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "token"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.token) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.token.isEmpty {
      try visitor.visitSingularStringField(value: self.token, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Sinch_Conversationapi_Type_TelegramCredentials, rhs: Sinch_Conversationapi_Type_TelegramCredentials) -> Bool {
    if lhs.token != rhs.token {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Sinch_Conversationapi_Type_InstagramCredentials: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".InstagramCredentials"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "token"),
    2: .standard(proto: "business_account_id"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.token) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.businessAccountID) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.token.isEmpty {
      try visitor.visitSingularStringField(value: self.token, fieldNumber: 1)
    }
    if !self.businessAccountID.isEmpty {
      try visitor.visitSingularStringField(value: self.businessAccountID, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Sinch_Conversationapi_Type_InstagramCredentials, rhs: Sinch_Conversationapi_Type_InstagramCredentials) -> Bool {
    if lhs.token != rhs.token {return false}
    if lhs.businessAccountID != rhs.businessAccountID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Sinch_Conversationapi_Type_KakaoTalkCredentials: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".KakaoTalkCredentials"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "kakaotalk_plus_friend_id"),
    2: .standard(proto: "kakaotalk_sender_key"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.kakaotalkPlusFriendID) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.kakaotalkSenderKey) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.kakaotalkPlusFriendID.isEmpty {
      try visitor.visitSingularStringField(value: self.kakaotalkPlusFriendID, fieldNumber: 1)
    }
    if !self.kakaotalkSenderKey.isEmpty {
      try visitor.visitSingularStringField(value: self.kakaotalkSenderKey, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Sinch_Conversationapi_Type_KakaoTalkCredentials, rhs: Sinch_Conversationapi_Type_KakaoTalkCredentials) -> Bool {
    if lhs.kakaotalkPlusFriendID != rhs.kakaotalkPlusFriendID {return false}
    if lhs.kakaotalkSenderKey != rhs.kakaotalkSenderKey {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Sinch_Conversationapi_Type_AppleBcCredentials: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".AppleBcCredentials"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "business_chat_account_id"),
    2: .standard(proto: "merchant_id"),
    3: .standard(proto: "apple_pay_certificate_reference"),
    4: .standard(proto: "apple_pay_certificate_password"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.businessChatAccountID) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.merchantID) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.applePayCertificateReference) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.applePayCertificatePassword) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.businessChatAccountID.isEmpty {
      try visitor.visitSingularStringField(value: self.businessChatAccountID, fieldNumber: 1)
    }
    if !self.merchantID.isEmpty {
      try visitor.visitSingularStringField(value: self.merchantID, fieldNumber: 2)
    }
    if !self.applePayCertificateReference.isEmpty {
      try visitor.visitSingularStringField(value: self.applePayCertificateReference, fieldNumber: 3)
    }
    if !self.applePayCertificatePassword.isEmpty {
      try visitor.visitSingularStringField(value: self.applePayCertificatePassword, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Sinch_Conversationapi_Type_AppleBcCredentials, rhs: Sinch_Conversationapi_Type_AppleBcCredentials) -> Bool {
    if lhs.businessChatAccountID != rhs.businessChatAccountID {return false}
    if lhs.merchantID != rhs.merchantID {return false}
    if lhs.applePayCertificateReference != rhs.applePayCertificateReference {return false}
    if lhs.applePayCertificatePassword != rhs.applePayCertificatePassword {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Sinch_Conversationapi_Type_ChannelIntegrationState: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ChannelIntegrationState"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "status"),
    2: .same(proto: "description"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.status) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.description_p) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.status != .pending {
      try visitor.visitSingularEnumField(value: self.status, fieldNumber: 1)
    }
    if !self.description_p.isEmpty {
      try visitor.visitSingularStringField(value: self.description_p, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Sinch_Conversationapi_Type_ChannelIntegrationState, rhs: Sinch_Conversationapi_Type_ChannelIntegrationState) -> Bool {
    if lhs.status != rhs.status {return false}
    if lhs.description_p != rhs.description_p {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Sinch_Conversationapi_Type_WeChatCredentials: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".WeChatCredentials"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "app_id"),
    2: .standard(proto: "app_secret"),
    3: .same(proto: "token"),
    4: .standard(proto: "aes_key"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.appID) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.appSecret) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.token) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.aesKey) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.appID.isEmpty {
      try visitor.visitSingularStringField(value: self.appID, fieldNumber: 1)
    }
    if !self.appSecret.isEmpty {
      try visitor.visitSingularStringField(value: self.appSecret, fieldNumber: 2)
    }
    if !self.token.isEmpty {
      try visitor.visitSingularStringField(value: self.token, fieldNumber: 3)
    }
    if !self.aesKey.isEmpty {
      try visitor.visitSingularStringField(value: self.aesKey, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Sinch_Conversationapi_Type_WeChatCredentials, rhs: Sinch_Conversationapi_Type_WeChatCredentials) -> Bool {
    if lhs.appID != rhs.appID {return false}
    if lhs.appSecret != rhs.appSecret {return false}
    if lhs.token != rhs.token {return false}
    if lhs.aesKey != rhs.aesKey {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Sinch_Conversationapi_Type_LineCredentials: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".LineCredentials"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "token"),
    2: .same(proto: "secret"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.token) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.secret) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.token.isEmpty {
      try visitor.visitSingularStringField(value: self.token, fieldNumber: 1)
    }
    if !self.secret.isEmpty {
      try visitor.visitSingularStringField(value: self.secret, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Sinch_Conversationapi_Type_LineCredentials, rhs: Sinch_Conversationapi_Type_LineCredentials) -> Bool {
    if lhs.token != rhs.token {return false}
    if lhs.secret != rhs.secret {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Sinch_Conversationapi_Type_KakaoTalkChatCredentials: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".KakaoTalkChatCredentials"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "kakaotalk_plus_friend_id"),
    2: .standard(proto: "api_key"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.kakaotalkPlusFriendID) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.apiKey) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.kakaotalkPlusFriendID.isEmpty {
      try visitor.visitSingularStringField(value: self.kakaotalkPlusFriendID, fieldNumber: 1)
    }
    if !self.apiKey.isEmpty {
      try visitor.visitSingularStringField(value: self.apiKey, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Sinch_Conversationapi_Type_KakaoTalkChatCredentials, rhs: Sinch_Conversationapi_Type_KakaoTalkChatCredentials) -> Bool {
    if lhs.kakaotalkPlusFriendID != rhs.kakaotalkPlusFriendID {return false}
    if lhs.apiKey != rhs.apiKey {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}
