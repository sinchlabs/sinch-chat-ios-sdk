// DO NOT EDIT.
// swift-format-ignore-file
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: sinch/conversationapi/adapter/v1beta/channel_callback_service.proto
//
// For information on using the generated types, please see the documentation:
//   https://github.com/apple/swift-protobuf/

import Foundation
import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that you are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

enum Sinch_Conversationapi_Adapter_V1beta_HmacAlgorithm: SwiftProtobuf.Enum {
  typealias RawValue = Int
  case unspecified // = 0
  case hmacSha256 // = 1
  case hmacSha1 // = 2
  case hmacMd5 // = 3
  case UNRECOGNIZED(Int)

  init() {
    self = .unspecified
  }

  init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .unspecified
    case 1: self = .hmacSha256
    case 2: self = .hmacSha1
    case 3: self = .hmacMd5
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  var rawValue: Int {
    switch self {
    case .unspecified: return 0
    case .hmacSha256: return 1
    case .hmacSha1: return 2
    case .hmacMd5: return 3
    case .UNRECOGNIZED(let i): return i
    }
  }

}

#if swift(>=4.2)

extension Sinch_Conversationapi_Adapter_V1beta_HmacAlgorithm: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  static var allCases: [Sinch_Conversationapi_Adapter_V1beta_HmacAlgorithm] = [
    .unspecified,
    .hmacSha256,
    .hmacSha1,
    .hmacMd5,
  ]
}

#endif  // swift(>=4.2)

struct Sinch_Conversationapi_Adapter_V1beta_SendChannelCallbackRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Required. Messages/events/delivery receipts contained in the request.
  var channelCallbacks: [Sinch_Conversationapi_Adapter_V1beta_ChannelCallbackRequest] = []

  /// Required. The Conversation API app ID of the receiving app.
  var appID: String = String()

  /// Optional. Callback verification data if available.
  var callbackVerification: Sinch_Conversationapi_Adapter_V1beta_ChannelCallbackVerification {
    get {return _callbackVerification ?? Sinch_Conversationapi_Adapter_V1beta_ChannelCallbackVerification()}
    set {_callbackVerification = newValue}
  }
  /// Returns true if `callbackVerification` has been explicitly set.
  var hasCallbackVerification: Bool {return self._callbackVerification != nil}
  /// Clears the value of `callbackVerification`. Subsequent reads from it will return its default value.
  mutating func clearCallbackVerification() {self._callbackVerification = nil}

  /// Required. The originating channel.
  var channel: Sinch_Conversationapi_Type_ConversationChannel = .channelUnspecified

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _callbackVerification: Sinch_Conversationapi_Adapter_V1beta_ChannelCallbackVerification? = nil
}

struct Sinch_Conversationapi_Adapter_V1beta_ChannelCallbackRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Required. Originator (Contact) channel identity. Can be left out for unsupported callback.
  var from: String = String()

  /// Optional. Recipient channel identity.
  var to: String = String()

  /// Required. The message_id generated by the channel.
  /// For MO Messages and Delivery Reports this is required but can be left out
  /// for events and unsupported callbacks 
  var channelMessageID: String = String()

  /// Required. The timestamp from the channel callback.
  var timestamp: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _timestamp ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_timestamp = newValue}
  }
  /// Returns true if `timestamp` has been explicitly set.
  var hasTimestamp: Bool {return self._timestamp != nil}
  /// Clears the value of `timestamp`. Subsequent reads from it will return its default value.
  mutating func clearTimestamp() {self._timestamp = nil}

  /// Required. The message.
  var message: Sinch_Conversationapi_Adapter_V1beta_ChannelCallbackRequest.OneOf_Message? = nil

  var contactMessage: Sinch_Conversationapi_Type_ContactMessage {
    get {
      if case .contactMessage(let v)? = message {return v}
      return Sinch_Conversationapi_Type_ContactMessage()
    }
    set {message = .contactMessage(newValue)}
  }

  var contactEvent: Sinch_Conversationapi_Type_ContactEvent {
    get {
      if case .contactEvent(let v)? = message {return v}
      return Sinch_Conversationapi_Type_ContactEvent()
    }
    set {message = .contactEvent(newValue)}
  }

  var deliveryReport: Sinch_Conversationapi_Adapter_Type_ChannelDeliveryReport {
    get {
      if case .deliveryReport(let v)? = message {return v}
      return Sinch_Conversationapi_Adapter_Type_ChannelDeliveryReport()
    }
    set {message = .deliveryReport(newValue)}
  }

  var unsupportedCallback: String {
    get {
      if case .unsupportedCallback(let v)? = message {return v}
      return String()
    }
    set {message = .unsupportedCallback(newValue)}
  }

  var optIn: SwiftProtobuf.Google_Protobuf_Empty {
    get {
      if case .optIn(let v)? = message {return v}
      return SwiftProtobuf.Google_Protobuf_Empty()
    }
    set {message = .optIn(newValue)}
  }

  var optOut: SwiftProtobuf.Google_Protobuf_Empty {
    get {
      if case .optOut(let v)? = message {return v}
      return SwiftProtobuf.Google_Protobuf_Empty()
    }
    set {message = .optOut(newValue)}
  }

  /// Optional. Used if the adapter wants to control the message id to user
  /// for the generated callback. Must be a valid ULID 
  var sinchMessageID: String = String()

  /// Optional. Additional properties.
  var additionalProperties: Sinch_Conversationapi_Adapter_V1beta_AdditionalProperties {
    get {return _additionalProperties ?? Sinch_Conversationapi_Adapter_V1beta_AdditionalProperties()}
    set {_additionalProperties = newValue}
  }
  /// Returns true if `additionalProperties` has been explicitly set.
  var hasAdditionalProperties: Bool {return self._additionalProperties != nil}
  /// Clears the value of `additionalProperties`. Subsequent reads from it will return its default value.
  mutating func clearAdditionalProperties() {self._additionalProperties = nil}

  /// Optional. The metadata_message will be used to propagate Mo metadata to callbacks.
  var metadataMessage: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  /// Required. The message.
  enum OneOf_Message: Equatable {
    case contactMessage(Sinch_Conversationapi_Type_ContactMessage)
    case contactEvent(Sinch_Conversationapi_Type_ContactEvent)
    case deliveryReport(Sinch_Conversationapi_Adapter_Type_ChannelDeliveryReport)
    case unsupportedCallback(String)
    case optIn(SwiftProtobuf.Google_Protobuf_Empty)
    case optOut(SwiftProtobuf.Google_Protobuf_Empty)

  #if !swift(>=4.1)
    static func ==(lhs: Sinch_Conversationapi_Adapter_V1beta_ChannelCallbackRequest.OneOf_Message, rhs: Sinch_Conversationapi_Adapter_V1beta_ChannelCallbackRequest.OneOf_Message) -> Bool {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch (lhs, rhs) {
      case (.contactMessage, .contactMessage): return {
        guard case .contactMessage(let l) = lhs, case .contactMessage(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.contactEvent, .contactEvent): return {
        guard case .contactEvent(let l) = lhs, case .contactEvent(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.deliveryReport, .deliveryReport): return {
        guard case .deliveryReport(let l) = lhs, case .deliveryReport(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.unsupportedCallback, .unsupportedCallback): return {
        guard case .unsupportedCallback(let l) = lhs, case .unsupportedCallback(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.optIn, .optIn): return {
        guard case .optIn(let l) = lhs, case .optIn(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.optOut, .optOut): return {
        guard case .optOut(let l) = lhs, case .optOut(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      default: return false
      }
    }
  #endif
  }

  init() {}

  fileprivate var _timestamp: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
  fileprivate var _additionalProperties: Sinch_Conversationapi_Adapter_V1beta_AdditionalProperties? = nil
}

struct Sinch_Conversationapi_Adapter_V1beta_SendChannelCallbackResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Required. The Conversation API app ID of the receiving app.
  var appID: String = String()

  /// If the request was erroneous then the error is presented here.
  var error: Sinch_Conversationapi_Adapter_Type_ChannelReason {
    get {return _error ?? Sinch_Conversationapi_Adapter_Type_ChannelReason()}
    set {_error = newValue}
  }
  /// Returns true if `error` has been explicitly set.
  var hasError: Bool {return self._error != nil}
  /// Clears the value of `error`. Subsequent reads from it will return its default value.
  mutating func clearError() {self._error = nil}

  var responses: [Sinch_Conversationapi_Adapter_V1beta_ChannelCallbackResponse] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _error: Sinch_Conversationapi_Adapter_Type_ChannelReason? = nil
}

struct Sinch_Conversationapi_Adapter_V1beta_ChannelCallbackResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Optional. The channel message ID for MO Messages and Delivery Reports.
  var channelMessageID: String = String()

  /// Optional. Conv API message ID if the callback is successfully queued.
  var sinchMessageID: String = String()

  /// Error in case the message/event/dr in the request was erroneous.
  var error: Sinch_Conversationapi_Adapter_Type_ChannelReason {
    get {return _error ?? Sinch_Conversationapi_Adapter_Type_ChannelReason()}
    set {_error = newValue}
  }
  /// Returns true if `error` has been explicitly set.
  var hasError: Bool {return self._error != nil}
  /// Clears the value of `error`. Subsequent reads from it will return its default value.
  mutating func clearError() {self._error = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _error: Sinch_Conversationapi_Adapter_Type_ChannelReason? = nil
}

struct Sinch_Conversationapi_Adapter_V1beta_ChannelCallbackVerification {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var message: Sinch_Conversationapi_Adapter_V1beta_ChannelCallbackVerification.OneOf_Message? = nil

  var basic: Sinch_Conversationapi_Adapter_V1beta_BasicAuthentication {
    get {
      if case .basic(let v)? = message {return v}
      return Sinch_Conversationapi_Adapter_V1beta_BasicAuthentication()
    }
    set {message = .basic(newValue)}
  }

  var hmac: Sinch_Conversationapi_Adapter_V1beta_HmacAuthentication {
    get {
      if case .hmac(let v)? = message {return v}
      return Sinch_Conversationapi_Adapter_V1beta_HmacAuthentication()
    }
    set {message = .hmac(newValue)}
  }

  var unknownFields = SwiftProtobuf.UnknownStorage()

  enum OneOf_Message: Equatable {
    case basic(Sinch_Conversationapi_Adapter_V1beta_BasicAuthentication)
    case hmac(Sinch_Conversationapi_Adapter_V1beta_HmacAuthentication)

  #if !swift(>=4.1)
    static func ==(lhs: Sinch_Conversationapi_Adapter_V1beta_ChannelCallbackVerification.OneOf_Message, rhs: Sinch_Conversationapi_Adapter_V1beta_ChannelCallbackVerification.OneOf_Message) -> Bool {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch (lhs, rhs) {
      case (.basic, .basic): return {
        guard case .basic(let l) = lhs, case .basic(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.hmac, .hmac): return {
        guard case .hmac(let l) = lhs, case .hmac(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      default: return false
      }
    }
  #endif
  }

  init() {}
}

struct Sinch_Conversationapi_Adapter_V1beta_BasicAuthentication {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Optional. Expected to be channel bot/account id if present.
  /// Max length is 256 characters. 
  var username: String = String()

  /// Required. Shared secret used to authenticate the call.
  /// Max length is 256 characters. 
  var password: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Sinch_Conversationapi_Adapter_V1beta_HmacAuthentication {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Required. The algorithm used for signing.
  var algorithm: Sinch_Conversationapi_Adapter_V1beta_HmacAlgorithm = .unspecified

  /// Required. HEX encoded.
  var signature: String = String()

  /// Required. UTF-8 encoded raw data which was used to create the signature.
  var signedData: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Sinch_Conversationapi_Adapter_V1beta_AdditionalProperties {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Optional. Contains channel specific contact name. 
  var contactName: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

// MARK: - Code below here is support for the SwiftProtobuf runtime.

fileprivate let _protobuf_package = "sinch.conversationapi.adapter.v1beta"

extension Sinch_Conversationapi_Adapter_V1beta_HmacAlgorithm: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "HMAC_ALGORITHM_UNSPECIFIED"),
    1: .same(proto: "HMAC_SHA_256"),
    2: .same(proto: "HMAC_SHA_1"),
    3: .same(proto: "HMAC_MD5"),
  ]
}

extension Sinch_Conversationapi_Adapter_V1beta_SendChannelCallbackRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".SendChannelCallbackRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "channel_callbacks"),
    2: .standard(proto: "app_id"),
    3: .standard(proto: "callback_verification"),
    4: .same(proto: "channel"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.channelCallbacks) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.appID) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._callbackVerification) }()
      case 4: try { try decoder.decodeSingularEnumField(value: &self.channel) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.channelCallbacks.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.channelCallbacks, fieldNumber: 1)
    }
    if !self.appID.isEmpty {
      try visitor.visitSingularStringField(value: self.appID, fieldNumber: 2)
    }
    try { if let v = self._callbackVerification {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    if self.channel != .channelUnspecified {
      try visitor.visitSingularEnumField(value: self.channel, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Sinch_Conversationapi_Adapter_V1beta_SendChannelCallbackRequest, rhs: Sinch_Conversationapi_Adapter_V1beta_SendChannelCallbackRequest) -> Bool {
    if lhs.channelCallbacks != rhs.channelCallbacks {return false}
    if lhs.appID != rhs.appID {return false}
    if lhs._callbackVerification != rhs._callbackVerification {return false}
    if lhs.channel != rhs.channel {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Sinch_Conversationapi_Adapter_V1beta_ChannelCallbackRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ChannelCallbackRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "from"),
    2: .same(proto: "to"),
    3: .standard(proto: "channel_message_id"),
    4: .same(proto: "timestamp"),
    5: .standard(proto: "contact_message"),
    6: .standard(proto: "contact_event"),
    7: .standard(proto: "delivery_report"),
    8: .standard(proto: "unsupported_callback"),
    9: .standard(proto: "opt_in"),
    10: .standard(proto: "opt_out"),
    11: .standard(proto: "sinch_message_id"),
    12: .standard(proto: "additional_properties"),
    13: .standard(proto: "metadata_message"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.from) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.to) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.channelMessageID) }()
      case 4: try { try decoder.decodeSingularMessageField(value: &self._timestamp) }()
      case 5: try {
        var v: Sinch_Conversationapi_Type_ContactMessage?
        var hadOneofValue = false
        if let current = self.message {
          hadOneofValue = true
          if case .contactMessage(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.message = .contactMessage(v)
        }
      }()
      case 6: try {
        var v: Sinch_Conversationapi_Type_ContactEvent?
        var hadOneofValue = false
        if let current = self.message {
          hadOneofValue = true
          if case .contactEvent(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.message = .contactEvent(v)
        }
      }()
      case 7: try {
        var v: Sinch_Conversationapi_Adapter_Type_ChannelDeliveryReport?
        var hadOneofValue = false
        if let current = self.message {
          hadOneofValue = true
          if case .deliveryReport(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.message = .deliveryReport(v)
        }
      }()
      case 8: try {
        var v: String?
        try decoder.decodeSingularStringField(value: &v)
        if let v = v {
          if self.message != nil {try decoder.handleConflictingOneOf()}
          self.message = .unsupportedCallback(v)
        }
      }()
      case 9: try {
        var v: SwiftProtobuf.Google_Protobuf_Empty?
        var hadOneofValue = false
        if let current = self.message {
          hadOneofValue = true
          if case .optIn(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.message = .optIn(v)
        }
      }()
      case 10: try {
        var v: SwiftProtobuf.Google_Protobuf_Empty?
        var hadOneofValue = false
        if let current = self.message {
          hadOneofValue = true
          if case .optOut(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.message = .optOut(v)
        }
      }()
      case 11: try { try decoder.decodeSingularStringField(value: &self.sinchMessageID) }()
      case 12: try { try decoder.decodeSingularMessageField(value: &self._additionalProperties) }()
      case 13: try { try decoder.decodeSingularStringField(value: &self.metadataMessage) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.from.isEmpty {
      try visitor.visitSingularStringField(value: self.from, fieldNumber: 1)
    }
    if !self.to.isEmpty {
      try visitor.visitSingularStringField(value: self.to, fieldNumber: 2)
    }
    if !self.channelMessageID.isEmpty {
      try visitor.visitSingularStringField(value: self.channelMessageID, fieldNumber: 3)
    }
    try { if let v = self._timestamp {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    } }()
    switch self.message {
    case .contactMessage?: try {
      guard case .contactMessage(let v)? = self.message else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
    }()
    case .contactEvent?: try {
      guard case .contactEvent(let v)? = self.message else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
    }()
    case .deliveryReport?: try {
      guard case .deliveryReport(let v)? = self.message else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 7)
    }()
    case .unsupportedCallback?: try {
      guard case .unsupportedCallback(let v)? = self.message else { preconditionFailure() }
      try visitor.visitSingularStringField(value: v, fieldNumber: 8)
    }()
    case .optIn?: try {
      guard case .optIn(let v)? = self.message else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 9)
    }()
    case .optOut?: try {
      guard case .optOut(let v)? = self.message else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 10)
    }()
    case nil: break
    }
    if !self.sinchMessageID.isEmpty {
      try visitor.visitSingularStringField(value: self.sinchMessageID, fieldNumber: 11)
    }
    try { if let v = self._additionalProperties {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 12)
    } }()
    if !self.metadataMessage.isEmpty {
      try visitor.visitSingularStringField(value: self.metadataMessage, fieldNumber: 13)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Sinch_Conversationapi_Adapter_V1beta_ChannelCallbackRequest, rhs: Sinch_Conversationapi_Adapter_V1beta_ChannelCallbackRequest) -> Bool {
    if lhs.from != rhs.from {return false}
    if lhs.to != rhs.to {return false}
    if lhs.channelMessageID != rhs.channelMessageID {return false}
    if lhs._timestamp != rhs._timestamp {return false}
    if lhs.message != rhs.message {return false}
    if lhs.sinchMessageID != rhs.sinchMessageID {return false}
    if lhs._additionalProperties != rhs._additionalProperties {return false}
    if lhs.metadataMessage != rhs.metadataMessage {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Sinch_Conversationapi_Adapter_V1beta_SendChannelCallbackResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".SendChannelCallbackResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "app_id"),
    2: .same(proto: "error"),
    3: .same(proto: "responses"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.appID) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._error) }()
      case 3: try { try decoder.decodeRepeatedMessageField(value: &self.responses) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.appID.isEmpty {
      try visitor.visitSingularStringField(value: self.appID, fieldNumber: 1)
    }
    try { if let v = self._error {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    if !self.responses.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.responses, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Sinch_Conversationapi_Adapter_V1beta_SendChannelCallbackResponse, rhs: Sinch_Conversationapi_Adapter_V1beta_SendChannelCallbackResponse) -> Bool {
    if lhs.appID != rhs.appID {return false}
    if lhs._error != rhs._error {return false}
    if lhs.responses != rhs.responses {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Sinch_Conversationapi_Adapter_V1beta_ChannelCallbackResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ChannelCallbackResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "channel_message_id"),
    2: .standard(proto: "sinch_message_id"),
    3: .same(proto: "error"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.channelMessageID) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.sinchMessageID) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._error) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.channelMessageID.isEmpty {
      try visitor.visitSingularStringField(value: self.channelMessageID, fieldNumber: 1)
    }
    if !self.sinchMessageID.isEmpty {
      try visitor.visitSingularStringField(value: self.sinchMessageID, fieldNumber: 2)
    }
    try { if let v = self._error {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Sinch_Conversationapi_Adapter_V1beta_ChannelCallbackResponse, rhs: Sinch_Conversationapi_Adapter_V1beta_ChannelCallbackResponse) -> Bool {
    if lhs.channelMessageID != rhs.channelMessageID {return false}
    if lhs.sinchMessageID != rhs.sinchMessageID {return false}
    if lhs._error != rhs._error {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Sinch_Conversationapi_Adapter_V1beta_ChannelCallbackVerification: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ChannelCallbackVerification"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "basic"),
    2: .same(proto: "hmac"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try {
        var v: Sinch_Conversationapi_Adapter_V1beta_BasicAuthentication?
        var hadOneofValue = false
        if let current = self.message {
          hadOneofValue = true
          if case .basic(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.message = .basic(v)
        }
      }()
      case 2: try {
        var v: Sinch_Conversationapi_Adapter_V1beta_HmacAuthentication?
        var hadOneofValue = false
        if let current = self.message {
          hadOneofValue = true
          if case .hmac(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.message = .hmac(v)
        }
      }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    switch self.message {
    case .basic?: try {
      guard case .basic(let v)? = self.message else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }()
    case .hmac?: try {
      guard case .hmac(let v)? = self.message else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Sinch_Conversationapi_Adapter_V1beta_ChannelCallbackVerification, rhs: Sinch_Conversationapi_Adapter_V1beta_ChannelCallbackVerification) -> Bool {
    if lhs.message != rhs.message {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Sinch_Conversationapi_Adapter_V1beta_BasicAuthentication: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".BasicAuthentication"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "username"),
    2: .same(proto: "password"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.username) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.password) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.username.isEmpty {
      try visitor.visitSingularStringField(value: self.username, fieldNumber: 1)
    }
    if !self.password.isEmpty {
      try visitor.visitSingularStringField(value: self.password, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Sinch_Conversationapi_Adapter_V1beta_BasicAuthentication, rhs: Sinch_Conversationapi_Adapter_V1beta_BasicAuthentication) -> Bool {
    if lhs.username != rhs.username {return false}
    if lhs.password != rhs.password {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Sinch_Conversationapi_Adapter_V1beta_HmacAuthentication: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".HmacAuthentication"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "algorithm"),
    2: .same(proto: "signature"),
    3: .standard(proto: "signed_data"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.algorithm) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.signature) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.signedData) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.algorithm != .unspecified {
      try visitor.visitSingularEnumField(value: self.algorithm, fieldNumber: 1)
    }
    if !self.signature.isEmpty {
      try visitor.visitSingularStringField(value: self.signature, fieldNumber: 2)
    }
    if !self.signedData.isEmpty {
      try visitor.visitSingularStringField(value: self.signedData, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Sinch_Conversationapi_Adapter_V1beta_HmacAuthentication, rhs: Sinch_Conversationapi_Adapter_V1beta_HmacAuthentication) -> Bool {
    if lhs.algorithm != rhs.algorithm {return false}
    if lhs.signature != rhs.signature {return false}
    if lhs.signedData != rhs.signedData {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Sinch_Conversationapi_Adapter_V1beta_AdditionalProperties: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".AdditionalProperties"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "contact_name"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.contactName) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.contactName.isEmpty {
      try visitor.visitSingularStringField(value: self.contactName, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Sinch_Conversationapi_Adapter_V1beta_AdditionalProperties, rhs: Sinch_Conversationapi_Adapter_V1beta_AdditionalProperties) -> Bool {
    if lhs.contactName != rhs.contactName {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}
